<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Chore Game - Home</title>
  <link rel="stylesheet" href="styles/main.css">
  <link rel="stylesheet" href="styles/index.css">
</head>

<body>
<header class="site-header">

  <div class="container">
    <a href="index.html">
      <img class="logo" src="images/cwLightM.png" alt="Logo">
    </a>
    <div class="container-logo">
      <a href="index.html">
        <img class src="images/Chore _Wars_logo_title_new.png" href="index.html" alt="The Chore Game">
      </a>
    </div>
    <nav class="main-nav">
      <a class="header-btn" href="index.html">Home</a>
      <a class="header-btn" href="shop.html">Shop</a>
    </nav>
  </div>
</header>

<body>

  <!-- ...existing code... -->
  <main class="site-main container">
    <section class="grid-3">
      <div class="column" id="column-left">
        <h3 class="column-header" contenteditable="true" spellcheck="false"
          aria-label="Column 1 header">Player 1</h3>

        <!-- left points bank (display only) -->
        <div class="points-bank">
          <div>Points: <strong id="left-points">0</strong></div>
        </div>

        <!-- left column chores -->
        <div id="left-list" class="chore-dropzone" data-loc="left">
          <article class="card chore-placeholder">No chores assigned.</article>
        </div>
      </div>

      <div class="column" id="chores-column">
        <h3 class="column-header" aria-label="Unchoosen Chores">Unassigned Chores</h3>

        <!-- random assign button -->
        <div class="button-container">
          <button id="random-assign-btn" type="button" class="btn">Random</button>
          <button id="auction-btn" type="button" class="btn">Auction</button>
          <button id="draft-btn" type="button" class="btn">Draft</button>
        </div>

        <!-- unchosen chores list (rendered by JS) -->
        <div id="chores-list" class="chore-dropzone" data-loc="unchosen">
          <article class="card chore-placeholder">No chores yet â€” add one below.</article>
        </div>

        <!-- add-chore form -->
        <form id="add-chore-form" class="chore-form" aria-label="Add chore" novalidate>
          <div class="form-row">
            <input id="chore-name" name="name" type="text" required aria-required="true" placeholder="Chore Name">
            <button type="submit" id="unchosen-button-add" class="btn">Add</button>
          </div>
        </form>
      </div>

      <div class="column" id="column-right">
        <h3 class="column-header" contenteditable="true" spellcheck="false"
          aria-label="Column 3 header">Player 2</h3>

        <!-- right points bank (display only) -->
        <div class="points-bank" id="right-points-bank">
          <div>Points: <strong id="right-points">0</strong></div>
        </div>

        <!-- right column chores -->
        <div id="right-list" class="chore-dropzone" data-loc="right">
          <article class="card chore-placeholder">No chores assigned.</article>
        </div>
      </div>
    </section>

    <!-- Button bar above footer -->
    <div id="bottom-buttons">
      <button id="add-column-btn" type="button" class="btn">Add Player</button>
      <button id="unassign-all-btn" type="button" class="btn">Unassign All</button>
      <button id="remove-column-btn" type="button" class="btn" disabled>Remove Player</button>
    </div>
  </main>
  <!-- ...existing code... -->

  <footer class="site-footer">
    <div class="container">
      <p>Â© <span id="year"></span> Chore Wars: Made By: Sean Heiner, Parker Dragovich, Cole Popejoy, John Wendt, & Kendall Olson!</p>
      <p id="group-display" style="margin-top: 8px; font-size: 0.9em; opacity: 0.8;"></p>
    </div>
  </footer>

  <!-- vvvv Java Script vvvv -->

  <!-- =========================================================================
    JAVASCRIPT ARCHITECTURE OVERVIEW
    =========================================================================
    
    This page contains several independent JavaScript modules:
    
    1. FOOTER YEAR UPDATER
       - Simple utility to display current year in copyright
    
    2. AUTHENTICATION & GROUP SYSTEM
       - Validates user login and group selection
       - Redirects to login.html if no session
       - Redirects to groups.html if no group selected
       - Updates navigation with Groups link and Logout button
       - Displays group ID in footer
    
    3. CORE CHORE MANAGEMENT SYSTEM (Main Module)
       - Chore CRUD operations (Create, Read, Update, Delete, Edit)
       - Points banking system for up to 10 players
       - Column/player management (dynamic 3-10 players)
       - Three assignment modes:
         a) Random: Balanced random distribution
         b) Auction: Players bid on chores (starting 50pts, decrements by 5)
         c) Draft: Rate chores as Easy (5-10pts) or Hard (15-25pts)
       - Manual assignment in draft mode
       - Chore completion (awards points, unassigns chore)
       - Inline editing of player names (8 char limit for P1/P2)
       - localStorage persistence (all data scoped by group)
    
    4. ADD/REMOVE PLAYER COLUMN SYSTEM
       - Dynamically adds/removes player columns (3-10 players)
       - Manages column positioning and reordering
       - Syncs with points, headers, and chore assignments
       - Handles chore reassignment when player removed
       - Updates CSS grid layout dynamically
    
    KEY DATA STRUCTURES:
    - Chore: { id, name, points, loc, difficulty? }
    - Points: { left, right, extra1-extra8 }
    - Headers: { left, right, extra1-extra8 }
    - ExtraState: { extra1-extra8: boolean }
    
    STORAGE KEYS (all group-scoped):
    - tcg_chores_v1_${groupId}
    - tcg_points_v1_${groupId}
    - tcg_column_headers_v1_${groupId}
    - tcg_extra_cols_v1_${groupId}
    - tcg_player_positions_v1_${groupId}
    
  ========================================================================= -->
  <!-- ========================================================================
    SUPER SIMPLE STORY (Kid-Friendly Explanation)
    ========================================================================
    Think of this page like a big toy shelf:
    - Each CHORE is a little task card (like a toy) that can sit on a shelf.
    - The SHELVES are the player columns (Player 1, Player 2, etc.).
    - The UNASSIGNED area is a pile of toys waiting to be picked.
    - When you "assign" a chore, you move the toy from the pile onto someone's shelf.
    - When a player "completes" a chore, they earn POINTS (like gold stars) and the toy goes back to the pile so someone can pick it later again.
    - RANDOM puts toys on shelves evenly so nobody gets too many.
    - AUCTION lets everyone say "I want it" until only one person still wants it. That person pays points (the price falls each round) and gets the chore.
    - DRAFT first asks: Is this chore EASY or HARD? That sets how many points it gives. Then you can manually give chores to players.
    - DRAG & DROP is like picking up a toy card and placing it on a different shelf.
    - Adding a PLAYER makes a new shelf appear; removing one hides a shelf and returns their toys to the pile.
    All the data (toys, shelves, points) is saved in your browser so if you refresh, your game stays the same for your group.
  ======================================================================== -->

  <script>
    // ===================================
    // FOOTER: Display current year
    // ===================================
    // Updates the footer copyright year dynamically to current year
    document.getElementById('year').textContent = new Date().getFullYear();
  </script>

  <script>
    // ===================================
    // AUTHENTICATION & GROUP SYSTEM
    // ===================================
    // Handles user login validation, group selection enforcement, and logout functionality
    // Redirects to login if no session, redirects to groups if no group selected
    // Updates navigation with Groups link and Logout button when authenticated
    (function() {
      const SESSION_KEY = 'tcg_session_v1';
      const CURRENT_GROUP_KEY = 'tcg_current_group_v1';
      
      // Check if user is logged in and has selected a group
      function checkAuthAndGroup() {
        const session = getSession();
        const currentGroup = getCurrentGroup();
        
        if (!session || !session.username) {
          window.location.href = 'login.html';
          return null;
        }
        
        if (!currentGroup) {
          window.location.href = 'groups.html';
          return null;
        }
        
        return { session, currentGroup };
      }
      
      function getSession() {
        try {
          const sessionData = localStorage.getItem(SESSION_KEY);
          return sessionData ? JSON.parse(sessionData) : null;
        } catch (e) {
          return null;
        }
      }
      
      function getCurrentGroup() {
        return localStorage.getItem(CURRENT_GROUP_KEY);
      }
      
      // Initialize auth check
      const authData = checkAuthAndGroup();
      if (!authData) return;
      
      // Update navigation
      const headerBtns = document.querySelector('.main-nav');
      if (headerBtns) {
          headerBtns.innerHTML = `
              <a class="header-btn" href="index.html">Home</a>
              <a class="header-btn" href="shop.html">Shop</a>
              <a class="header-btn" href="groups.html">Groups</a>
              <button id="logout-btn" class="header-btn">Logout</button>
          `;
          
          // Add logout confirmation modal
          function askLogoutConfirm() {
            return new Promise((resolve) => {
              const overlay = document.createElement('div');
              overlay.className = 'tcg-modal-overlay';

              const modal = document.createElement('div');
              modal.className = 'tcg-modal';

              modal.innerHTML = `
                <p><strong>Confirm Logout</strong></p>
                <p>Are you sure you want to logout? You'll need to sign in again to access your groups.</p>
                <div class="tcg-modal-actions">
                  <button class="btn-confirm">Logout</button>
                  <button class="btn-cancel">Cancel</button>
                </div>
              `;

              overlay.appendChild(modal);
              document.body.appendChild(overlay);

              function cleanup() {
                document.body.removeChild(overlay);
              }

              function onConfirm() {
                cleanup();
                resolve(true);
              }

              function onCancel() {
                cleanup();
                resolve(false);
              }

              modal.querySelector('.btn-confirm').addEventListener('click', onConfirm);
              modal.querySelector('.btn-cancel').addEventListener('click', onCancel);
              overlay.addEventListener('click', (e) => {
                if (e.target === overlay) onCancel();
              });
            });
          }

          // Add logout functionality
          document.getElementById('logout-btn').addEventListener('click', async () => {
              const confirmed = await askLogoutConfirm();
              if (confirmed) {
                  // Attempt to persist current group state and user data before clearing
                  try {
                    const groupId = localStorage.getItem('tcg_current_group_v1');
                    if (groupId && groupId !== 'default') {
                      const fullState = {
                        chores: JSON.parse(localStorage.getItem(`tcg_chores_v1_${groupId}`) || '[]'),
                        points: JSON.parse(localStorage.getItem(`tcg_points_v1_${groupId}`) || '{}'),
                        headers: JSON.parse(localStorage.getItem(`tcg_column_headers_v1_${groupId}`) || '{}'),
                        extraState: JSON.parse(localStorage.getItem(`tcg_extra_cols_v1_${groupId}`) || '{}')
                      };

                      // Save group state to server
                      await fetch('/api/save_game_state.php', {
                        method: 'POST',
                        credentials: 'same-origin',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ groupId: groupId, data: fullState })
                      });

                      // Save user's personal account data as well (best-effort)
                      const sessionRaw = localStorage.getItem('tcg_session_v1');
                      if (sessionRaw) {
                        try {
                          await fetch('/api/save_user_data.php', {
                            method: 'POST',
                            credentials: 'same-origin',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ data: fullState })
                          });
                        } catch (e) {
                          // ignore user-data save errors
                        }
                      }

                      // small delay to allow server round-trip
                      await new Promise(r => setTimeout(r, 300));
                    }
                  } catch (e) {
                    console.error('Error saving state before logout:', e);
                  }

                  // Clear session + current group
                  localStorage.removeItem('tcg_session_v1');
                  localStorage.removeItem('tcg_current_group_v1');

                  // ðŸ”´ C.3: wipe all chore/shop data cached in this browser
                  Object.keys(localStorage).forEach(key => {
                      if (key.startsWith('tcg_')) {
                          localStorage.removeItem(key);
                      }
                  });

                  // Go back to login
                  window.location.href = 'login.html';
              }
          });
        }

        const groupDisplay = document.getElementById('group-display');
        if (groupDisplay) {
            const groupRaw = authData.currentGroup;
            const groupId = groupRaw.replace(/\D+/g, ''); // remove non-digits
            groupDisplay.textContent = `Group: ${groupId}`;
        }
      }
    )();
  </script>

  <script>
    // ===================================
    // CORE CHORE MANAGEMENT SYSTEM
    // ===================================
    // Main chore tracking system with localStorage persistence (group-scoped)
    // Handles: chore creation, assignment, completion, deletion, and column management
    // Supports up to 10 players with dynamic column addition/removal
    // Manages points banking system and column header editing
    (function () {
      // ===================================
      // STORAGE KEYS & CONFIGURATION
      // ===================================
      // Get current group for scoped storage - all data is isolated per group
      function getCurrentGroup() {
        return localStorage.getItem('tcg_current_group_v1') || 'default';
      }
      
      // Storage keys must be functions to always get fresh group ID
      function getStorageKey() { return `tcg_chores_v1_${getCurrentGroup()}`; }
      function getHeadersKey() { return `tcg_column_headers_v1_${getCurrentGroup()}`; }
      function getPointsKey() { return `tcg_points_v1_${getCurrentGroup()}`; }
      function getExtraStateKey() { return `tcg_extra_cols_v1_${getCurrentGroup()}`; }
      
      // Legacy constants for backward compatibility - but these will be wrong after group switch!
      // Use the getter functions above instead
      const STORAGE_KEY = getStorageKey();
      const HEADERS_KEY = getHeadersKey();
      const POINTS_KEY = getPointsKey();
      const EXTRA_STATE_KEY = getExtraStateKey();

      const SESSION_KEY_SERVER = 'tcg_session_v1';

      function getSessionForServer() {
        try {
          const raw = localStorage.getItem(SESSION_KEY_SERVER);
          return raw ? JSON.parse(raw) : null;
        } catch (e) {
          return null;
        }
      }

      // Build a full snapshot of the game state to send to the server
      function buildFullGameState() {
        return {
          chores: loadChores(),
          points: loadPoints(),
          headers: loadAllHeaders(),
          extraState: loadExtraState()
        };
      }

      async function saveStateToServer(fullState) {
        const session = getSessionForServer();
        if (!session || !session.userId) return;
        if (!currentGroup || currentGroup === 'default') return;

        try {
          await fetch('/api/save_game_state.php', {
            method: 'POST',
            credentials: 'same-origin',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              groupId: currentGroup,
              data: fullState
            })
          });
        } catch (e) {
          console.error('Error saving game state to server', e);
        }
      }

      let serverSaveTimeoutId = null;
      function queueServerSave() {
        const state = buildFullGameState();
        if (serverSaveTimeoutId) {
          clearTimeout(serverSaveTimeoutId);
        }
        serverSaveTimeoutId = setTimeout(() => {
          saveStateToServer(state);
        }, 500);
      }

      // Saves the full game state to the user's personal account (cross-device sync)
      async function saveUserDataToAccount() {
        const fullState = buildFullGameState();
        
        try {
          const response = await fetch('/api/save_user_data.php', {
            method: 'POST',
            credentials: 'same-origin',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              data: fullState
            })
          });

          if (!response.ok) {
            console.error('Failed to save user data:', response.status);
            return false;
          }

          const result = await response.json();
          return result.ok === true;
        } catch (e) {
          console.error('Error saving user data to account:', e);
          return false;
        }
      }

      async function loadStateFromServer() {
        const currentGroup = getCurrentGroup();
        if (!currentGroup || currentGroup === 'default') return;

        // Always clear localStorage first to ensure fresh load
        localStorage.removeItem(getStorageKey());
        localStorage.removeItem(getPointsKey());
        localStorage.removeItem(getHeadersKey());
        localStorage.removeItem(getExtraStateKey());

        try {
          const res = await fetch(`/api/get_game_state.php?groupId=${encodeURIComponent(currentGroup)}`, { credentials: 'same-origin' });
          
          if (!res.ok) {
            // Server has no data - initialize empty state
            console.log('[loadStateFromServer] No response from server, initializing empty state');
            localStorage.setItem(getStorageKey(), JSON.stringify([]));
            localStorage.setItem(getPointsKey(), JSON.stringify({ left: 0, right: 0, extra1: 0, extra2: 0, extra3: 0, extra4: 0, extra5: 0, extra6: 0, extra7: 0, extra8: 0 }));
            localStorage.setItem(getHeadersKey(), JSON.stringify({}));
            localStorage.setItem(getExtraStateKey(), JSON.stringify({ extra1: false, extra2: false, extra3: false, extra4: false, extra5: false, extra6: false, extra7: false, extra8: false }));
            return;
          }

          const data = await res.json();

          if (!data) {
            // No DB state for this group - initialize empty
            console.log('[loadStateFromServer] No data in DB for group', currentGroup, '- initializing empty');
            localStorage.setItem(getStorageKey(), JSON.stringify([]));
            localStorage.setItem(getPointsKey(), JSON.stringify({ left: 0, right: 0, extra1: 0, extra2: 0, extra3: 0, extra4: 0, extra5: 0, extra6: 0, extra7: 0, extra8: 0 }));
            localStorage.setItem(getHeadersKey(), JSON.stringify({}));
            localStorage.setItem(getExtraStateKey(), JSON.stringify({ extra1: false, extra2: false, extra3: false, extra4: false, extra5: false, extra6: false, extra7: false, extra8: false }));
            return;
          }

          // Server has data - load it
          console.log('[loadStateFromServer] Loaded data from server:', data);
          localStorage.setItem(getStorageKey(), JSON.stringify(data.chores || []));
          localStorage.setItem(getPointsKey(), JSON.stringify(data.points || { left: 0, right: 0, extra1: 0, extra2: 0, extra3: 0, extra4: 0, extra5: 0, extra6: 0, extra7: 0, extra8: 0 }));
          localStorage.setItem(getHeadersKey(), JSON.stringify(data.headers || {}));
          localStorage.setItem(getExtraStateKey(), JSON.stringify(data.extraState || { extra1: false, extra2: false, extra3: false, extra4: false, extra5: false, extra6: false, extra7: false, extra8: false }));
        } catch (e) {
          console.error('Error loading game state from server', e);
          // On error, initialize empty state
          localStorage.setItem(getStorageKey(), JSON.stringify([]));
          localStorage.setItem(getPointsKey(), JSON.stringify({ left: 0, right: 0, extra1: 0, extra2: 0, extra3: 0, extra4: 0, extra5: 0, extra6: 0, extra7: 0, extra8: 0 }));
          localStorage.setItem(getHeadersKey(), JSON.stringify({}));
          localStorage.setItem(getExtraStateKey(), JSON.stringify({ extra1: false, extra2: false, extra3: false, extra4: false, extra5: false, extra6: false, extra7: false, extra8: false }));
        }
      }

      // Loads user's personal game data from their account (cross-device sync)
      async function loadUserData() {
        try {
          const res = await fetch('/api/load_user_data.php', { credentials: 'same-origin' });
          if (!res.ok) return null;

          const result = await res.json();
          if (result.ok && result.data) {
            return result.data;
          }
          return null;
        } catch (e) {
          console.error('Error loading user data from server', e);
          return null;
        }
      }

      // Merges user data (from account) with current local data
      // Strategy: Use server data only if local storage is completely empty
      async function mergeUserDataIfNeeded() {
        // DISABLED: This legacy cross-device sync is incompatible with group-based storage.
        // Group data is now loaded via loadStateFromServer() which is group-aware.
        // Keeping this function would overwrite empty new groups with old non-group data.
        return;
        
        /* OLD CODE - DISABLED
        const userData = await loadUserData();
        if (!userData) return;

        // Check if local storage has any data already
        const hasLocalChores = (loadChores() || []).length > 0;
        const hasLocalPoints = Object.values(loadPoints() || {}).some(v => v);

        // If local storage is empty, restore from user account data
        if (!hasLocalChores && !hasLocalPoints) {
          if (userData.chores) {
            localStorage.setItem(getStorageKey(), JSON.stringify(userData.chores));
          }
          if (userData.points) {
            localStorage.setItem(getPointsKey(), JSON.stringify(userData.points));
          }
          if (userData.headers) {
            localStorage.setItem(getHeadersKey(), JSON.stringify(userData.headers));
          }
          if (userData.extraState) {
            localStorage.setItem(getExtraStateKey(), JSON.stringify(userData.extraState));
          }
          console.log('Restored game data from user account');
        }
        */
      }

      const HEADER_MAX = 8; // Max characters allowed for left/right headers

      // ===================================
      // POINTS SYSTEM
      // ===================================
      // Loads points from localStorage for all players (left, right, extra1-8)
      function loadPoints() {
        // Kid-Friendly: "Load the scoreboards"
        // We open the saved box of points. If a player is missing, we give them 0.
        try {
          const raw = localStorage.getItem(getPointsKey());
          let parsed = raw ? JSON.parse(raw) : { left: 0, right: 0 };
          
          // Handle case where points was stored as an array instead of object
          if (Array.isArray(parsed)) {
            console.warn('[loadPoints] Points was stored as array, converting to object:', parsed);
            parsed = { left: 0, right: 0 };
          }
          
          // ensure extra fields exist for compatibility
          if (typeof parsed.left !== 'number') parsed.left = 0;
          if (typeof parsed.right !== 'number') parsed.right = 0;
          if (typeof parsed.extra1 !== 'number') parsed.extra1 = 0;
          if (typeof parsed.extra2 !== 'number') parsed.extra2 = 0;
          if (typeof parsed.extra3 !== 'number') parsed.extra3 = 0;
          if (typeof parsed.extra4 !== 'number') parsed.extra4 = 0;
          if (typeof parsed.extra5 !== 'number') parsed.extra5 = 0;
          if (typeof parsed.extra6 !== 'number') parsed.extra6 = 0;
          if (typeof parsed.extra7 !== 'number') parsed.extra7 = 0;
          if (typeof parsed.extra8 !== 'number') parsed.extra8 = 0;
          return parsed;
        } catch (e) {
          console.error('[loadPoints] Error parsing points:', e);
          return { left: 0, right: 0, extra1: 0, extra2: 0, extra3: 0, extra4: 0, extra5: 0, extra6: 0, extra7: 0, extra8: 0 };
        }
      }
      // Saves points object to localStorage
      function savePoints(p) { 
        console.log('[savePoints] Saving to localStorage with key:', getPointsKey(), 'value:', JSON.stringify(p));
        localStorage.setItem(getPointsKey(), JSON.stringify(p)); 
        console.log('[savePoints] Stored to localStorage, now calling queueServerSave');
        queueServerSave(); 
      }
      
      // Updates all points displays in the DOM
      function renderPoints() {
        // Kid-Friendly: "Update the scoreboard displays"
        // We look at the stored points and set the numbers on the page.
        const p = loadPoints();
        console.log('[renderPoints] Loaded points:', JSON.stringify(p));
        const leftEl = document.getElementById('left-points');
        const rightEl = document.getElementById('right-points');
        const extra1El = document.getElementById('extra1-points');
        const extra2El = document.getElementById('extra2-points');
        const extra3El = document.getElementById('extra3-points');
        const extra4El = document.getElementById('extra4-points');
        const extra5El = document.getElementById('extra5-points');
        const extra6El = document.getElementById('extra6-points');
        const extra7El = document.getElementById('extra7-points');
        const extra8El = document.getElementById('extra8-points');
        if (leftEl) { 
          leftEl.textContent = String(p.left || 0); 
          console.log('[renderPoints] Set left-points element to:', p.left, 'Element now shows:', leftEl.textContent);
        }
        if (rightEl) { 
          rightEl.textContent = String(p.right || 0); 
          console.log('[renderPoints] Set right-points element to:', p.right, 'Element now shows:', rightEl.textContent);
        }
        if (extra1El) extra1El.textContent = String(p.extra1 || 0);
        if (extra2El) extra2El.textContent = String(p.extra2 || 0);
        if (extra3El) extra3El.textContent = String(p.extra3 || 0);
        if (extra4El) extra4El.textContent = String(p.extra4 || 0);
        if (extra5El) extra5El.textContent = String(p.extra5 || 0);
        if (extra6El) extra6El.textContent = String(p.extra6 || 0);
        if (extra7El) extra7El.textContent = String(p.extra7 || 0);
        if (extra8El) extra8El.textContent = String(p.extra8 || 0);
      }

      // ===================================
      // EXTRA COLUMNS MANAGEMENT
      // ===================================
      // Tracks which extra player columns (3-10) are currently active
      function loadExtraState() {
        try {
          const raw = localStorage.getItem(getExtraStateKey());
          const parsed = raw ? JSON.parse(raw) : { extra1: false, extra2: false, extra3: false, extra4: false, extra5: false, extra6: false, extra7: false, extra8: false };
          return {
            extra1: !!parsed.extra1,
            extra2: !!parsed.extra2,
            extra3: !!parsed.extra3,
            extra4: !!parsed.extra4,
            extra5: !!parsed.extra5,
            extra6: !!parsed.extra6,
            extra7: !!parsed.extra7,
            extra8: !!parsed.extra8
          };
        } catch (e) {
          return { extra1: false, extra2: false, extra3: false, extra4: false, extra5: false, extra6: false, extra7: false, extra8: false };
        }
      }
      // Saves extra columns state to localStorage
      function saveExtraState(s) { localStorage.setItem(getExtraStateKey(), JSON.stringify(s)); queueServerSave(); }

      // ===================================
      // HEADER MANAGEMENT (Player Names)
      // ===================================
      // Loads all column headers (player names) from localStorage
      function loadAllHeaders() {
        try {
          const raw = localStorage.getItem(getHeadersKey());
          return raw ? JSON.parse(raw) : {};
        } catch (e) { return {}; }
      }
      // Saves a single header field (player name) to localStorage
      function saveHeaderField(field, value) {
        const obj = loadAllHeaders();
        obj[field] = value;
        localStorage.setItem(getHeadersKey(), JSON.stringify(obj));
        queueServerSave();
      }

      // ===================================
      // POINTS QUICK CONTROLS
      // ===================================
      // Add 10 points or reset buttons for left/right players (if they exist in DOM),
      // and load the latest game state from the server on page load.
      document.addEventListener('DOMContentLoaded', async () => {
        // IMPORTANT: Check if group has changed since page loaded
        // If so, reload to get fresh data for the new group
        const pageLoadGroup = getCurrentGroup();
        const currentPageGroup = localStorage.getItem('tcg_current_group_v1') || 'default';
        if (pageLoadGroup !== currentPageGroup) {
          console.log('[DOMContentLoaded] Group changed from', pageLoadGroup, 'to', currentPageGroup, '- reloading page');
          window.location.reload();
          return;
        }

        const leftAdd = document.getElementById('left-add-10');
        const leftReset = document.getElementById('left-reset');
        const rightAdd = document.getElementById('right-add-10');
        const rightReset = document.getElementById('right-reset');

        if (leftAdd) {
          leftAdd.addEventListener('click', () => {
            const p = loadPoints();
            p.left = (p.left || 0) + 10;
            savePoints(p);
            renderPoints();
          });
        }
        if (leftReset) {
          leftReset.addEventListener('click', () => {
            if (!confirm('Reset left points to 0?')) return;
            const p = loadPoints();
            p.left = 0;
            savePoints(p);
            renderPoints();
          });
        }
        if (rightAdd) {
          rightAdd.addEventListener('click', () => {
            const p = loadPoints();
            p.right = (p.right || 0) + 10;
            savePoints(p);
            renderPoints();
          });
        }
        if (rightReset) {
          rightReset.addEventListener('click', () => {
            if (!confirm('Reset right points to 0?')) return;
            const p = loadPoints();
            p.right = 0;
            savePoints(p);
            renderPoints();
          });
        }

        // First, try to load any saved state for this group from the server.
        await loadStateFromServer();

        // Then, try to load user's personal account data if on a new device (cross-device sync)
        await mergeUserDataIfNeeded();

        // Then render the chores and the scoreboard based on whatever is now in storage.
        if (typeof render === 'function') {
          render();
        }
        renderPoints();
      });

      // Listen for logout event to save user data
      // Save group state when requested before logout
      window.addEventListener('saveGroupStateBeforeLogout', async () => {
        try {
          await saveStateToServer(buildFullGameState());
        } catch (e) {
          console.error('Error saving group state before logout:', e);
        }
      });

      // Listen for logout event to save user data
      window.addEventListener('saveUserDataBeforeLogout', async () => {
        await saveUserDataToAccount();
      });

      // Watch for group changes and reload page if detected
      // This ensures we always display data for the currently selected group
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          // Page came back into focus
          const pageLoadGroup = getCurrentGroup();
          const currentPageGroup = localStorage.getItem('tcg_current_group_v1') || 'default';
          if (pageLoadGroup !== currentPageGroup) {
            console.log('[visibilitychange] Group changed from', pageLoadGroup, 'to', currentPageGroup, '- reloading page');
            window.location.reload();
          }
        }
      });


      // ===================================
      // EDITABLE HEADERS (Player 1 & 2)
      // ===================================
      // Makes left and right column headers (player names) editable inline
      // Enforces max character limit and saves on blur/enter
      const leftHeaderEl = document.querySelector('.grid-3 .column:nth-child(1) .column-header');
      const rightHeaderEl = document.querySelector('.grid-3 .column:nth-child(3) .column-header');

      // Loads left/right player names from localStorage or uses defaults
      function loadHeaders() {
        try {
          const raw = localStorage.getItem(getHeadersKey());
          const parsed = raw ? JSON.parse(raw) : {};
          return {
            left: parsed.left ?? (leftHeaderEl ? leftHeaderEl.textContent.trim() : 'Enter Name Here'),
            right: parsed.right ?? (rightHeaderEl ? rightHeaderEl.textContent.trim() : 'Enter Name Here')
          };
        } catch (e) {
          return {
            left: leftHeaderEl ? leftHeaderEl.textContent.trim() : 'Enter Name Here',
            right: rightHeaderEl ? rightHeaderEl.textContent.trim() : 'Enter Name Here'
          };
        }
      }

      // Saves left/right headers to localStorage (enforces character limit)
      function saveHeaders() {
        if (!leftHeaderEl || !rightHeaderEl) return;
        const leftText = (leftHeaderEl.textContent || '').replace(/[\r\n]+/g, '').trim().slice(0, HEADER_MAX);
        const rightText = (rightHeaderEl.textContent || '').replace(/[\r\n]+/g, '').trim().slice(0, HEADER_MAX);
        const existing = loadAllHeaders();
        const payload = { ...existing, left: leftText, right: rightText };
        localStorage.setItem(getHeadersKey(), JSON.stringify(payload));
      }

      // Apply saved headers immediately on page load
      const savedHeaders = loadHeaders();
      if (leftHeaderEl) leftHeaderEl.textContent = savedHeaders.left;
      if (rightHeaderEl) rightHeaderEl.textContent = savedHeaders.right;
      saveHeaders(); // Save any normalization

      // ===================================
      // DOM ELEMENTS & STATE
      // ===================================
      // Main DOM elements used throughout the chore system
      const leftListEl = document.getElementById('left-list');
      const unchosenListEl = document.getElementById('chores-list');
      const rightListEl = document.getElementById('right-list');
      const form = document.getElementById('add-chore-form');
      const nameInput = document.getElementById('chore-name');
      const msgEl = document.getElementById('chore-msg');

      // Track whether we're in draft mode (enables manual assign buttons on chores)
      let draftMode = false;

      // ===================================
      // NOTIFICATION HELPER
      // ===================================
      // Shows temporary message in the form message area
      function notify(message, durationMs = 1800) {
        if (!msgEl) return;
        msgEl.textContent = message || '';
        if (message) {
          setTimeout(() => { if (msgEl) msgEl.textContent = ''; }, durationMs);
        }
      }

      // ===================================
      // CHORE DATA PERSISTENCE
      // ===================================
      // Chores have structure: { id, name, points, loc, difficulty? }
      // loc can be: 'unchosen', 'left', 'right', 'extra1'-'extra8'
      // Kid-Friendly: Think of a chore object like a trading card:
      // id = its unique number, name = what to do, points = how shiny it is,
      // loc = which shelf it's sitting on, difficulty = easy or hard sticker.
      
      // Loads all chores from localStorage
      function loadChores() {
        try {
          const raw = localStorage.getItem(getStorageKey());
          return raw ? JSON.parse(raw) : [];
        } catch (e) {
          return [];
        }
      }

      // Saves chores array to localStorage and syncs to server
      function saveChores(chores) {
        localStorage.setItem(getStorageKey(), JSON.stringify(chores));
        queueServerSave();
      }

      // ===================================
      // CHORE CARD RENDERING
      // ===================================
      // Creates a chore card DOM element with buttons based on location and draft mode
      // Shows different buttons: Complete/Unassign for assigned chores
      // Shows Assign buttons in draft mode, Delete and Edit buttons for all chores
      function makeChoreCard(chore) {
        // Kid-Friendly: This builds a little "card" that shows the chore.
        // It can have buttons to: give it to someone, finish it, edit it, or delete it.
        // If we are in DRAFT MODE and the chore has a difficulty, we show lots of assign buttons.
        const art = document.createElement('article');
        art.className = 'card chore';
        art.dataset.id = String(chore.id);
        art.dataset.loc = chore.loc || 'unchosen';
        // Drag & Drop enablement for chore reassignment
        art.draggable = true;
        art.addEventListener('dragstart', (e) => {
          // Kid-Friendly: We pick up the chore card. Store its id so we know which one it is when dropped.
          e.dataTransfer.setData('text/chore-id', String(chore.id));
          e.dataTransfer.effectAllowed = 'move';
          art.classList.add('dragging');
        });
        art.addEventListener('dragend', () => {
          // Kid-Friendly: We let go of the card. Remove the "dragging" look.
          art.classList.remove('dragging');
        });

      

        const wrap = document.createElement('div');
        wrap.style.width = '100%';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.alignItems = 'center';

        const title = document.createElement('h4');
        title.textContent = chore.name;
        title.style.margin = '0 0 6px 0';
        title.style.textAlign = 'center';
        wrap.appendChild(title);

        const pts = document.createElement('p');
        pts.textContent = String(chore.points) + ' pts';
        pts.style.margin = '0 0 8px 0';
        pts.style.fontWeight = '600';
        pts.style.textAlign = 'center';
        wrap.appendChild(pts);

        const actions = document.createElement('div');
        actions.style.marginTop = '8px';
        actions.style.display = 'flex';
        actions.style.gap = '8px';
        actions.style.flexWrap = 'wrap';
        actions.style.justifyContent = 'center';
        actions.style.width = '100%';

        // read current column header text so labels match whatever the headers show
        const leftHeaderText = document.querySelector('.grid-3 .column:nth-child(1) .column-header')?.textContent.trim() || 'Left';
        const rightHeaderText = document.querySelector('.grid-3 .column:nth-child(3) .column-header')?.textContent.trim() || 'Right';
        const extra1HeaderText = document.querySelector('#column-extra1 .column-header')?.textContent.trim();
        const extra2HeaderText = document.querySelector('#column-extra2 .column-header')?.textContent.trim();
        const extra3HeaderText = document.querySelector('#column-extra3 .column-header')?.textContent.trim();
        const extra4HeaderText = document.querySelector('#column-extra4 .column-header')?.textContent.trim();
        const extra5HeaderText = document.querySelector('#column-extra5 .column-header')?.textContent.trim();
        const extra6HeaderText = document.querySelector('#column-extra6 .column-header')?.textContent.trim();
        const extra7HeaderText = document.querySelector('#column-extra7 .column-header')?.textContent.trim();
        const extra8HeaderText = document.querySelector('#column-extra8 .column-header')?.textContent.trim();

        // action buttons depend on location
        if (!chore.loc || chore.loc === 'unchosen') {
          // Only show assign buttons if in draft mode AND chore has difficulty rating
          if (draftMode && (chore.difficulty === 'easy' || chore.difficulty === 'difficult')) {
            // Mark card as having manual assign buttons for CSS styling
            art.dataset.hasButtons = 'true';
            
            const assignLeft = document.createElement('button');
            assignLeft.type = 'button';
            assignLeft.className = 'btn';
            assignLeft.innerHTML = `Assign â†’ <span style="color: #66CED6; font-weight: bold;">${leftHeaderText.toUpperCase()}</span>`;
            assignLeft.dataset.action = 'assign-left';
            actions.appendChild(assignLeft);

            const assignRight = document.createElement('button');
            assignRight.type = 'button';
            assignRight.className = 'btn';
            assignRight.innerHTML = `Assign â†’ <span style="color: #FF4242; font-weight: bold;">${rightHeaderText.toUpperCase()}</span>`;
            assignRight.dataset.action = 'assign-right';
            actions.appendChild(assignRight);

            // Add extra column buttons if they exist
            if (extra1HeaderText) {
              const assignExtra1 = document.createElement('button');
              assignExtra1.type = 'button';
              assignExtra1.className = 'btn';
              assignExtra1.innerHTML = `Assign â†’ <span style="color: orange; font-weight: bold;">${extra1HeaderText.toUpperCase()}</span>`;
              assignExtra1.dataset.action = 'assign-extra1';
              actions.appendChild(assignExtra1);
            }

            if (extra2HeaderText) {
              const assignExtra2 = document.createElement('button');
              assignExtra2.type = 'button';
              assignExtra2.className = 'btn';
              assignExtra2.innerHTML = `Assign â†’ <span style="color: limegreen; font-weight: bold;">${extra2HeaderText.toUpperCase()}</span>`;
              assignExtra2.dataset.action = 'assign-extra2';
              actions.appendChild(assignExtra2);
            }

            if (extra3HeaderText) {
              const assignExtra3 = document.createElement('button');
              assignExtra3.type = 'button';
              assignExtra3.className = 'btn';
              assignExtra3.innerHTML = `Assign â†’ <span style="color: purple; font-weight: bold;">${extra3HeaderText.toUpperCase()}</span>`;
              assignExtra3.dataset.action = 'assign-extra3';
              actions.appendChild(assignExtra3);
            }

            if (extra4HeaderText) {
              const assignExtra4 = document.createElement('button');
              assignExtra4.type = 'button';
              assignExtra4.className = 'btn';
              assignExtra4.innerHTML = `Assign â†’ <span style="color: yellow; font-weight: bold;">${extra4HeaderText.toUpperCase()}</span>`;
              assignExtra4.dataset.action = 'assign-extra4';
              actions.appendChild(assignExtra4);
            }

            if (extra5HeaderText) {
              const assignExtra5 = document.createElement('button');
              assignExtra5.type = 'button';
              assignExtra5.className = 'btn';
              assignExtra5.innerHTML = `Assign â†’ <span style="color: pink; font-weight: bold;">${extra5HeaderText.toUpperCase()}</span>`;
              assignExtra5.dataset.action = 'assign-extra5';
              actions.appendChild(assignExtra5);
            }

            if (extra6HeaderText) {
              const assignExtra6 = document.createElement('button');
              assignExtra6.type = 'button';
              assignExtra6.className = 'btn';
              assignExtra6.innerHTML = `Assign â†’ <span style="color: brown; font-weight: bold;">${extra6HeaderText.toUpperCase()}</span>`;
              assignExtra6.dataset.action = 'assign-extra6';
              actions.appendChild(assignExtra6);
            }

            if (extra7HeaderText) {
              const assignExtra7 = document.createElement('button');
              assignExtra7.type = 'button';
              assignExtra7.className = 'btn';
              assignExtra7.innerHTML = `Assign â†’ <span style="color: gray; font-weight: bold;">${extra7HeaderText.toUpperCase()}</span>`;
              assignExtra7.dataset.action = 'assign-extra7';
              actions.appendChild(assignExtra7);
            }

            if (extra8HeaderText) {
              const assignExtra8 = document.createElement('button');
              assignExtra8.type = 'button';
              assignExtra8.className = 'btn';
              assignExtra8.innerHTML = `Assign â†’ <span style="color: teal; font-weight: bold;">${extra8HeaderText.toUpperCase()}</span>`;
              assignExtra8.dataset.action = 'assign-extra8';
              actions.appendChild(assignExtra8);
            }

            // Count total buttons for sizing and add appropriate data attribute
            const buttonCount = actions.children.length;
            if (buttonCount >= 9) {
              art.dataset.buttonCount = 'many'; // 9-10 buttons (nearly all or all players)
            } else if (buttonCount >= 6) {
              art.dataset.buttonCount = 'medium'; // 6-8 buttons (many players)
            }
            // 2-5 buttons get default styling (no extra attribute needed)
            
            // Debug: Log button count for verification
            console.log(`Chore "${chore.name}" has ${buttonCount} manual assign buttons`);

            // In draft mode, show delete button separately at bottom center
            wrap.appendChild(actions);

            const delWrap = document.createElement('div');
            delWrap.style.marginTop = '12px';
            delWrap.style.display = 'flex';
            delWrap.style.justifyContent = 'center';
            delWrap.style.width = '100%';

            const del = document.createElement('button');
            del.type = 'button';
            del.className = 'btn btn-delete';
            del.textContent = 'Delete';
            del.dataset.action = 'delete';
            delWrap.appendChild(del);
            wrap.appendChild(delWrap);

            art.appendChild(wrap);
            return art;
          } else {
            // Mark card as NOT having manual assign buttons for CSS styling
            art.dataset.hasButtons = 'false';
          }
        } else {
          // show complete button for assigned chores
          const completeBtn = document.createElement('button');
          completeBtn.type = 'button';
          completeBtn.className = 'btn btn-purchase';
          completeBtn.textContent = 'Complete';
          completeBtn.dataset.action = 'complete';
          actions.appendChild(completeBtn);

          const unassign = document.createElement('button');
          unassign.type = 'button';
          unassign.className = 'btn';
          unassign.textContent = 'Unassign';
          unassign.dataset.action = 'unassign';
          actions.appendChild(unassign);
        }

        const del = document.createElement('button');
        del.type = 'button';
        del.className = 'btn btn-delete';
        del.textContent = 'Delete';
        del.dataset.action = 'delete';
        actions.appendChild(del);

        const edit = document.createElement('button');
        edit.type = 'button';
        edit.className = 'btn';
        edit.textContent = 'Edit';
        edit.dataset.action = 'edit';
        actions.appendChild(edit);

        wrap.appendChild(actions);
        art.appendChild(wrap);
        return art;
      }

        // ===================================
        // DRAG & DROP SETUP
        // ===================================
        function initDropZones() {
          // Kid-Friendly: Mark all the shelves and the pile so we can drop chore cards onto them.
          const zoneDefs = [
            { id: 'chores-list', loc: 'unchosen' },
            { id: 'left-list', loc: 'left' },
            { id: 'right-list', loc: 'right' },
            { id: 'extra1-list', loc: 'extra1' },
            { id: 'extra2-list', loc: 'extra2' },
            { id: 'extra3-list', loc: 'extra3' },
            { id: 'extra4-list', loc: 'extra4' },
            { id: 'extra5-list', loc: 'extra5' },
            { id: 'extra6-list', loc: 'extra6' },
            { id: 'extra7-list', loc: 'extra7' },
            { id: 'extra8-list', loc: 'extra8' }
          ];
          zoneDefs.forEach(def => {
            const el = document.getElementById(def.id);
            if (el) {
              el.dataset.loc = def.loc;
              el.classList.add('chore-dropzone');
            }
          });
        }
        // Delegated drag events for dynamic columns
        document.addEventListener('dragenter', (e) => {
          const zone = e.target.closest('.chore-dropzone');
          if (zone) { e.preventDefault(); zone.classList.add('drop-target'); }
        });
        document.addEventListener('dragover', (e) => {
          const zone = e.target.closest('.chore-dropzone');
          if (zone) e.preventDefault();
        });
        document.addEventListener('dragleave', (e) => {
          const zone = e.target.closest('.chore-dropzone');
          if (zone) zone.classList.remove('drop-target');
        });
        document.addEventListener('drop', (e) => {
          const zone = e.target.closest('.chore-dropzone');
          if (!zone) return;
          e.preventDefault();
          zone.classList.remove('drop-target');
          const id = e.dataTransfer.getData('text/chore-id');
          if (!id) return;
          const chores = loadChores();
          const chore = chores.find(c => String(c.id) === id);
          if (!chore) return;
          const loc = zone.dataset.loc || 'unchosen';
          if (loc === 'unchosen') { chore.loc = 'unchosen'; draftMode = true; } else { chore.loc = loc; }
          // Kid-Friendly: We moved the card to a new shelf (or back to the pile). Then we redraw everything so it looks right.
          saveChores(chores);
          render();
        });
        document.addEventListener('extra-column-created', () => initDropZones());
        // Initialize on load
        initDropZones();
      // ===================================
      // EDIT CHORE MODAL
      // ===================================
      // Opens a modal to edit chore name and points (5-50 pts, multiples of 5)
      // Validates inputs and updates chore in localStorage
      function editChore(choreId) {
        // Kid-Friendly: Show a mini window where we can change the chore's name and points.
        const chores = loadChores();
        const idx = chores.findIndex(c => c.id === choreId);
        if (idx === -1) return;
        const chore = chores[idx];

        return new Promise((resolve) => {
          const overlay = document.createElement('div');
          overlay.className = 'tcg-modal-overlay';
          
          const modal = document.createElement('div');
          modal.className = 'tcg-modal';
          
          modal.innerHTML = `
            <p><strong>Edit Chore</strong></p>
            <div style="margin: 15px 0;">
              <label style="display: block; margin-bottom: 5px; font-weight: 600;">Chore Name:</label>
              <input type="text" id="edit-chore-name" value="${chore.name}" 
                     style="width: 100%; padding: 8px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 1rem;" />
            </div>
            <div style="margin: 15px 0;">
              <label style="display: block; margin-bottom: 5px; font-weight: 600;">Points:</label>
              <input type="number" id="edit-chore-points" value="${chore.points}" min="5" max="50" step="5" 
                     style="width: 100%; padding: 8px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 1rem;" />
            </div>
            <div class="tcg-modal-actions">
              <button class="btn-cancel">Cancel</button>
              <button class="btn-confirm">Save</button>
            </div>
          `;
          
          overlay.appendChild(modal);
          document.body.appendChild(overlay);
          
          const nameInput = modal.querySelector('#edit-chore-name');
          const pointsInput = modal.querySelector('#edit-chore-points');
          nameInput.focus();
          nameInput.select();
          
          function cleanup() {
            document.body.removeChild(overlay);
          }
          
          function onConfirm() {
            const newName = nameInput.value.trim();
            const newPoints = parseInt(pointsInput.value) || 5;
            
            if (!newName) {
              nameInput.focus();
              return;
            }
            
            // Round points to nearest 5 and cap at 50
            let roundedPoints = Math.round(newPoints / 5) * 5;
            roundedPoints = Math.max(5, Math.min(50, roundedPoints));
            
            // Update the chore
            chores[idx].name = newName;
            chores[idx].points = roundedPoints;
            saveChores(chores);
            render();
            
            cleanup();
            notify(`Chore updated: ${newName} (${roundedPoints} pts)`, 1800);
            resolve(true);
          }
          
          function onCancel() {
            cleanup();
            resolve(false);
          }
          
          modal.querySelector('.btn-confirm').addEventListener('click', onConfirm);
          modal.querySelector('.btn-cancel').addEventListener('click', onCancel);
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) onCancel();
          });
          
          nameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              onConfirm();
            } else if (e.key === 'Escape') {
              onCancel();
            }
          });
          
          pointsInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              onConfirm();
            } else if (e.key === 'Escape') {
              onCancel();
            }
          });
        });
      }

      // ===================================
      // MAIN RENDER FUNCTION
      // ===================================
      // Renders all chores to appropriate columns (left, right, extra1-8, unchosen)
      // Updates DOM with chore cards and placeholder messages
      // Manages extra column visibility and player count CSS variable
      function render() {
        // Kid-Friendly: "Redraw the world"
        // Clear each shelf and rebuild it with its chore cards.
        // If a shelf is empty, show a friendly placeholder message.
        const chores = loadChores();

        leftListEl.innerHTML = '';
        unchosenListEl.innerHTML = '';
        rightListEl.innerHTML = '';

        const left = chores.filter(c => c.loc === 'left');
        const right = chores.filter(c => c.loc === 'right');
        const unchosen = chores.filter(c => !c.loc || c.loc === 'unchosen');

        if (!left.length) {
          const ph = document.createElement('article');
          ph.className = 'card chore-placeholder';
          ph.textContent = 'No chores assigned.';
          leftListEl.appendChild(ph);
        } else {
          left.forEach(c => leftListEl.appendChild(makeChoreCard(c)));
        }

        if (!unchosen.length) {
          const ph = document.createElement('article');
          ph.className = 'card chore-placeholder';
          ph.textContent = 'No chores yet â€” add one below.';
          unchosenListEl.appendChild(ph);
        } else {
          unchosen.forEach(c => unchosenListEl.appendChild(makeChoreCard(c)));
        }

        if (!right.length) {
          const ph = document.createElement('article');
          ph.className = 'card chore-placeholder';
          ph.textContent = 'No chores assigned.';
          rightListEl.appendChild(ph);
        } else {
          right.forEach(c => rightListEl.appendChild(makeChoreCard(c)));
        }

        // Extra columns rendering if present
        const extra1ListEl = document.getElementById('extra1-list');
        const extra2ListEl = document.getElementById('extra2-list');
        const extra3ListEl = document.getElementById('extra3-list');
        const extra4ListEl = document.getElementById('extra4-list');
        const extra5ListEl = document.getElementById('extra5-list');
        const extra6ListEl = document.getElementById('extra6-list');
        const extra7ListEl = document.getElementById('extra7-list');
        const extra8ListEl = document.getElementById('extra8-list');
        const extra1 = chores.filter(c => c.loc === 'extra1');
        const extra2 = chores.filter(c => c.loc === 'extra2');
        const extra3 = chores.filter(c => c.loc === 'extra3');
        const extra4 = chores.filter(c => c.loc === 'extra4');
        const extra5 = chores.filter(c => c.loc === 'extra5');
        const extra6 = chores.filter(c => c.loc === 'extra6');
        const extra7 = chores.filter(c => c.loc === 'extra7');
        const extra8 = chores.filter(c => c.loc === 'extra8');

        if (extra1ListEl) {
          extra1ListEl.innerHTML = '';
          if (!extra1.length) {
            const ph = document.createElement('article');
            ph.className = 'card chore-placeholder';
            ph.textContent = 'No chores assigned.';
            extra1ListEl.appendChild(ph);
          } else {
            extra1.forEach(c => extra1ListEl.appendChild(makeChoreCard(c)));
          }
        }
        if (extra2ListEl) {
          extra2ListEl.innerHTML = '';
          if (!extra2.length) {
            const ph = document.createElement('article');
            ph.className = 'card chore-placeholder';
            ph.textContent = 'No chores assigned.';
            extra2ListEl.appendChild(ph);
          } else {
            extra2.forEach(c => extra2ListEl.appendChild(makeChoreCard(c)));
          }
        }
        if (extra3ListEl) {
          extra3ListEl.innerHTML = '';
          if (!extra3.length) {
            const ph = document.createElement('article');
            ph.className = 'card chore-placeholder';
            ph.textContent = 'No chores assigned.';
            extra3ListEl.appendChild(ph);
          } else {
            extra3.forEach(c => extra3ListEl.appendChild(makeChoreCard(c)));
          }
        }
        if (extra4ListEl) {
          extra4ListEl.innerHTML = '';
          if (!extra4.length) {
            const ph = document.createElement('article');
            ph.className = 'card chore-placeholder';
            ph.textContent = 'No chores assigned.';
            extra4ListEl.appendChild(ph);
          } else {
            extra4.forEach(c => extra4ListEl.appendChild(makeChoreCard(c)));
          }
        }
        if (extra5ListEl) {
          extra5ListEl.innerHTML = '';
          if (!extra5.length) {
            const ph = document.createElement('article');
            ph.className = 'card chore-placeholder';
            ph.textContent = 'No chores assigned.';
            extra5ListEl.appendChild(ph);
          } else {
            extra5.forEach(c => extra5ListEl.appendChild(makeChoreCard(c)));
          }
        }
        if (extra6ListEl) {
          extra6ListEl.innerHTML = '';
          if (!extra6.length) {
            const ph = document.createElement('article');
            ph.className = 'card chore-placeholder';
            ph.textContent = 'No chores assigned.';
            extra6ListEl.appendChild(ph);
          } else {
            extra6.forEach(c => extra6ListEl.appendChild(makeChoreCard(c)));
          }
        }
        if (extra7ListEl) {
          extra7ListEl.innerHTML = '';
          if (!extra7.length) {
            const ph = document.createElement('article');
            ph.className = 'card chore-placeholder';
            ph.textContent = 'No chores assigned.';
            extra7ListEl.appendChild(ph);
          } else {
            extra7.forEach(c => extra7ListEl.appendChild(makeChoreCard(c)));
          }
        }
        if (extra8ListEl) {
          extra8ListEl.innerHTML = '';
          if (!extra8.length) {
            const ph = document.createElement('article');
            ph.className = 'card chore-placeholder';
            ph.textContent = 'No chores assigned.';
            extra8ListEl.appendChild(ph);
          } else {
            extra8.forEach(c => extra8ListEl.appendChild(makeChoreCard(c)));
          }
        }
        // Refresh drag & drop zones after rendering (handles dynamic columns)
        initDropZones();
      }

      // ===================================
      // ADD CHORE FORM HANDLER
      // ===================================
      // Handles chore creation from the form
      // Creates chore with default 10 points and unique ID
      // Disables draft mode when new chore is added
      form.addEventListener('submit', function (e) {
        e.preventDefault();

        const name = nameInput.value.trim();
        const points = 10; // fixed starting value

        if (!name) {
          nameInput.focus();
          return;
        }

        const chores = loadChores();
        const newChore = { id: Date.now(), name, points: Math.floor(points), loc: 'unchosen' };
        chores.push(newChore);
        saveChores(chores);
        draftMode = false; // Disable manual assign buttons when adding new chore
        render();
        form.reset();
      });

      // ===================================
      // CHORE ACTION HANDLER (Event Delegation)
      // ===================================
      // Handles all button clicks on chore cards: complete, unassign, assign, delete, edit
      // Uses event delegation on grid-3 container for performance
      document.querySelector('.grid-3').addEventListener('click', function (e) {
        // Kid-Friendly: One big ear listens for ANY button on ANY chore card.
        // This way we don't have to put a separate ear on every single card.
        const btn = e.target.closest('button[data-action]');
        if (!btn) return;
        const action = btn.dataset.action;
        const card = btn.closest('.chore');
        if (!card) return;
        const id = Number(card.dataset.id);
        let chores = loadChores();
        const idx = chores.findIndex(c => c.id === id);
        if (idx === -1) return;

        // ===================================
        // COMPLETE ACTION
        // ===================================
        // Awards points to player, then unassigns chore (moves back to unassigned column)
        if (action === 'complete') {
          const chore = chores[idx];
          const loc = chore.loc;
          if (!loc || !(['left', 'right', 'extra1', 'extra2', 'extra3', 'extra4', 'extra5', 'extra6', 'extra7', 'extra8'].includes(loc))) {
            notify('Chore must be assigned to a column to complete.', 1800);
            return;
          }
          console.log('[COMPLETE] Starting completion for chore:', chore.name, 'at location:', loc, 'with points:', chore.points);
          const points = loadPoints();
          console.log('[COMPLETE] Before adding points:', JSON.stringify(points));
          points[loc] = (points[loc] || 0) + Number(chore.points || 0);
          console.log('[COMPLETE] After adding points:', JSON.stringify(points));
          savePoints(points);
          console.log('[COMPLETE] Called savePoints, now calling renderPoints');
          renderPoints();

          // unassign the chore after completion instead of deleting
          chores[idx].loc = null;
          saveChores(chores);
          render();

          // Friendly target name
          let targetName = loc;
          if (loc === 'left') {
            targetName = (leftHeaderEl?.textContent || 'Left').trim();
          } else if (loc === 'right') {
            targetName = (rightHeaderEl?.textContent || 'Right').trim();
          } else if (loc === 'extra1') {
            const h = document.querySelector('#column-extra1 .column-header');
            targetName = (h?.textContent || 'Player 3').trim();
          } else if (loc === 'extra2') {
            const h = document.querySelector('#column-extra2 .column-header');
            targetName = (h?.textContent || 'Player 4').trim();
          } else if (loc === 'extra3') {
            const h = document.querySelector('#column-extra3 .column-header');
            targetName = (h?.textContent || 'Player 5').trim();
          } else if (loc === 'extra4') {
            const h = document.querySelector('#column-extra4 .column-header');
            targetName = (h?.textContent || 'Player 6').trim();
          } else if (loc === 'extra5') {
            const h = document.querySelector('#column-extra5 .column-header');
            targetName = (h?.textContent || 'Player 7').trim();
          } else if (loc === 'extra6') {
            const h = document.querySelector('#column-extra6 .column-header');
            targetName = (h?.textContent || 'Player 8').trim();
          } else if (loc === 'extra7') {
            const h = document.querySelector('#column-extra7 .column-header');
            targetName = (h?.textContent || 'Player 9').trim();
          } else if (loc === 'extra8') {
            const h = document.querySelector('#column-extra8 .column-header');
            targetName = (h?.textContent || 'Player 10').trim();
          }

          notify(`${chore.name} completed â€” added ${chore.points} pts to ${targetName}.`, 1800);
          return;
        }

        // ===================================
        // ASSIGN ACTIONS (Manual Assignment in Draft Mode)
        // ===================================
        // Assigns chore to specific player column
        if (action === 'assign-left') {
          chores[idx].loc = 'left';
          saveChores(chores);
          render();
          return;
        }
        if (action === 'assign-right') {
          chores[idx].loc = 'right';
          saveChores(chores);
          render();
          return;
        }
        if (action === 'assign-extra1') {
          chores[idx].loc = 'extra1';
          saveChores(chores);
          render();
          return;
        }
        if (action === 'assign-extra2') {
          chores[idx].loc = 'extra2';
          saveChores(chores);
          render();
          return;
        }
        if (action === 'assign-extra3') {
          chores[idx].loc = 'extra3';
          saveChores(chores);
          render();
          return;
        }
        if (action === 'assign-extra4') {
          chores[idx].loc = 'extra4';
          saveChores(chores);
          render();
          return;
        }
        if (action === 'assign-extra5') {
          chores[idx].loc = 'extra5';
          saveChores(chores);
          render();
          return;
        }
        if (action === 'assign-extra6') {
          chores[idx].loc = 'extra6';
          saveChores(chores);
          render();
          return;
        }
        if (action === 'assign-extra7') {
          chores[idx].loc = 'extra7';
          saveChores(chores);
          render();
          return;
        }
        if (action === 'assign-extra8') {
          chores[idx].loc = 'extra8';
          saveChores(chores);
          render();
          return;
        }
        // Unassigns chore back to unchosen column and enables draft mode
        if (action === 'unassign') {
          chores[idx].loc = 'unchosen';
          draftMode = true; // Enable draft mode so manual assign buttons appear
          saveChores(chores);
          render();
          return;
        }
        // Opens edit modal for the chore
        if (action === 'edit') {
          editChore(id);
          return;
        }
        // Deletes chore immediately without confirmation
        if (action === 'delete') {
          // delete immediately without confirmation
          chores.splice(idx, 1);
          saveChores(chores);
          render();
          notify('Chore deleted.', 1400);
          return;
        }
      });

      // ===================================
      // RANDOM ASSIGN BUTTON
      // ===================================
      // Distributes all unassigned chores randomly across all active players
      // Uses balanced assignment (aims for equal counts, max difference of 1)
      const randomAssignBtn = document.getElementById('random-assign-btn');
      if (randomAssignBtn) {
        // balanced assignment: aim for equal counts (difference at most 1)
        randomAssignBtn.addEventListener('click', function () {
          try {
            const chores = loadChores();
            const unchosen = chores.filter(c => !c.loc || c.loc === 'unchosen');
            if (!unchosen.length) {
              notify('No unassigned chores to assign.', 1800);
              return;
            }

            // Get all currently active players
            const activePlayers = getActivePlayers();
            if (activePlayers.length === 0) {
              notify('No active players to assign chores to.', 1800);
              return;
            }

            // Extract destination locations from active players
            const destinations = activePlayers.map(player => player.loc);

            // counts per destination
            const counts = Object.fromEntries(destinations.map(d => [d, 0]));
            chores.forEach(c => { if (destinations.includes(c.loc)) counts[c.loc]++; });

            // shuffle unchosen so distribution is not deterministic
            for (let i = unchosen.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [unchosen[i], unchosen[j]] = [unchosen[j], unchosen[i]];
            }

            // assign each unchosen chore to the destination with the fewest items
            const idsToAssign = new Set(unchosen.map(c => c.id));
            console.log('About to assign chores:', unchosen.length, 'to destinations:', destinations);
            chores.forEach(c => {
              if (!idsToAssign.has(c.id)) return;
              let min = Infinity;
              destinations.forEach(d => { if (counts[d] < min) min = counts[d]; });
              const mins = destinations.filter(d => counts[d] === min);
              const pick = mins[Math.floor(Math.random() * mins.length)];
              console.log('Assigning chore', c.name, 'to', pick);
              c.loc = pick;
              counts[pick]++;
            });
            console.log('Final assignment counts:', counts);

            // Calculate points based on assignment order
            // First assigned chores get lower points, last assigned gets 50 points
            const currentlyAssigning = Array.from(idsToAssign).length;

            // Sort the IDs to assign so we process them in a consistent order
            const sortedIdsToAssign = Array.from(idsToAssign).sort();

            // Calculate points for each chore being assigned
            sortedIdsToAssign.forEach((id, index) => {
              const chore = chores.find(c => c.id === id);
              if (!chore) return;

              // For the very last chore being assigned
              if (index === currentlyAssigning - 1) {
                chore.points = 50;
              } else {
                // Scale points from 10 to 40 based on position
                const progress = index / (currentlyAssigning - 1);  // 0 to 1
                const basePoints = 10 + (progress * 30);  // 10 to 40
                // Round up to nearest 5
                chore.points = Math.ceil(basePoints / 5) * 5;
              }
            });

            draftMode = false; // Disable manual assignment buttons
            console.log('About to save chores. Total chores:', chores.length);
            console.log('Chores by location:', chores.reduce((acc, c) => { acc[c.loc] = (acc[c.loc] || 0) + 1; return acc; }, {}));
            saveChores(chores);
            render();
            notify(`Assigned ${unchosen.length} chore(s) (balanced).`, 1800);
          } catch (error) {
            console.error('Error in random assign:', error);
            notify('Error assigning chores. Please try again.', 1800);
          }
        });
      }

      // Auction flow helpers
      function askYesNo(message, yesLabel = 'Yes', noLabel = 'No') {
        return new Promise(resolve => {
          const overlay = document.createElement('div');
          overlay.className = 'tcg-modal-overlay';
          const modal = document.createElement('div');
          modal.className = 'tcg-modal';

          const p = document.createElement('p');
          p.textContent = message;
          const actions = document.createElement('div');
          actions.className = 'tcg-modal-actions';

          const yesBtn = document.createElement('button');
          yesBtn.textContent = yesLabel;
          const noBtn = document.createElement('button');
          noBtn.textContent = noLabel;

          function cleanup(result) {
            document.removeEventListener('keydown', onKey);
            overlay.remove();
            resolve(result);
          }
          function onKey(e) {
            if (e.key === 'Escape') cleanup(false);
            if (e.key === 'Enter') cleanup(true);
          }

          yesBtn.addEventListener('click', () => cleanup(true));
          noBtn.addEventListener('click', () => cleanup(false));
          document.addEventListener('keydown', onKey);

          actions.appendChild(noBtn);
          actions.appendChild(yesBtn);
          modal.appendChild(p);
          modal.appendChild(actions);
          overlay.appendChild(modal);
          document.body.appendChild(overlay);
        });
      }

      // ask with Quit option: resolves 'yes' | 'no' | 'quit'
      function askYesNoQuit(message, yesLabel = 'Yes', noLabel = 'No', quitLabel = 'Quit Auction') {
        return new Promise(resolve => {
          const overlay = document.createElement('div');
          overlay.className = 'tcg-modal-overlay';
          const modal = document.createElement('div');
          modal.className = 'tcg-modal';

          const p = document.createElement('p');
          p.innerHTML = message; // Changed to innerHTML to support colored text
          const actions = document.createElement('div');
          actions.className = 'tcg-modal-actions';

          const quitBtn = document.createElement('button');
          quitBtn.textContent = quitLabel;
          quitBtn.className = 'btn-delete';
          const noBtn = document.createElement('button');
          noBtn.textContent = noLabel;
          const yesBtn = document.createElement('button');
          yesBtn.textContent = yesLabel;

          function cleanup(result) {
            document.removeEventListener('keydown', onKey);
            try { overlay.remove(); } catch (e) { }
            resolve(result);
          }
          function onKey(e) {
            if (e.key === 'Escape') cleanup('no');
            if (e.key === 'Enter') cleanup('yes');
          }

          quitBtn.addEventListener('click', () => cleanup('quit'));
          noBtn.addEventListener('click', () => cleanup('no'));
          yesBtn.addEventListener('click', () => cleanup('yes'));
          document.addEventListener('keydown', onKey);

          // Order buttons: Quit (left, destructive), No, Yes
          actions.appendChild(quitBtn);
          actions.appendChild(noBtn);
          actions.appendChild(yesBtn);
          modal.appendChild(p);
          modal.appendChild(actions);
          overlay.appendChild(modal);
          document.body.appendChild(overlay);
        });
      }

      // ===================================
      // DRAFT MODE: HIGH/LOW MODAL
      // ===================================
      // Asks user to rate chore difficulty (Easy or Hard) with option to quit draft
      // Returns 'easy', 'difficult', or null (if quit)
      function askHighOrLow(choreName) {
        return new Promise(resolve => {
          const overlay = document.createElement('div');
          overlay.className = 'tcg-modal-overlay';
          const modal = document.createElement('div');
          modal.className = 'tcg-modal';

          const p = document.createElement('p');
          p.textContent = `How difficult is: ${choreName}`;
          const actions = document.createElement('div');
          actions.className = 'tcg-modal-actions';

          const quitBtn = document.createElement('button');
          quitBtn.textContent = 'Quit Draft';
          quitBtn.className = 'btn-delete';
          quitBtn.style.backgroundColor = '#E24A4A';
          quitBtn.style.color = 'white';
          
          const lowBtn = document.createElement('button');
          lowBtn.textContent = 'Easy';
          
          const highBtn = document.createElement('button');
          highBtn.textContent = 'Hard';

          function cleanup(choice) {
            document.removeEventListener('keydown', onKey);
            overlay.remove();
            resolve(choice);
          }
          
          function onKey(e) {
            if (e.key === 'Escape') cleanup('quit');
            if (e.key === 'Enter') cleanup('high'); // Default to Hard on Enter
          }

          quitBtn.addEventListener('click', () => cleanup('quit'));
          lowBtn.addEventListener('click', () => cleanup('low'));
          highBtn.addEventListener('click', () => cleanup('high'));
          document.addEventListener('keydown', onKey);

          // Order buttons: Quit (left, destructive), Easy, Hard
          actions.appendChild(quitBtn);
          actions.appendChild(lowBtn);
          actions.appendChild(highBtn);
          modal.appendChild(p);
          modal.appendChild(actions);
          overlay.appendChild(modal);
          document.body.appendChild(overlay);
        });
      }

      // New simultaneous auction function where all players decide at once
      async function auctionSingleSimultaneous(chore, bidders) {
        let currentPrice = 45;
        let activeBidders = [...bidders];

        while (currentPrice >= 5 && activeBidders.length > 0) {
          // If we're at 5 points, randomly assign to one of the remaining bidders
          if (currentPrice === 5) {
            const randomBidder = activeBidders[Math.floor(Math.random() * activeBidders.length)];
            chore.loc = randomBidder.loc;
            chore.points = 5;
            return { abort: false };
          }

          // Show all players simultaneously and let them decide
          const responses = await askAllPlayersSimultaneous(chore, activeBidders, currentPrice);
          
          if (responses === 'quit') {
            return { abort: true };
          }

          // Filter to only bidders who said yes
          activeBidders = responses.filter(r => r.accepted).map(r => r.bidder);

          // If only one bidder left, assign to them at current price
          if (activeBidders.length === 1) {
            chore.loc = activeBidders[0].loc;
            chore.points = currentPrice;
            return { abort: false };
          }

          // If no one left, assign to random original bidder at 5 points
          if (activeBidders.length === 0) {
            const randomBidder = bidders[Math.floor(Math.random() * bidders.length)];
            chore.loc = randomBidder.loc;
            chore.points = 5;
            return { abort: false };
          }

          // Lower the price for next round
          currentPrice -= 5;
        }

        // Fallback: assign to random remaining bidder at 5 points
        if (activeBidders.length > 0) {
          const randomBidder = activeBidders[Math.floor(Math.random() * activeBidders.length)];
          chore.loc = randomBidder.loc;
          chore.points = 5;
          return { abort: false };
        } else {
          const randomBidder = bidders[Math.floor(Math.random() * bidders.length)];
          chore.loc = randomBidder.loc;
          chore.points = 5;
          return { abort: false };
        }
      }

      // ===================================
      // AUCTION MODE: ALL PLAYERS MODAL
      // ===================================
      // Shows simultaneous decision interface for all players
      // Each player chooses "Stay In" or "Pass" at current price
      // Returns array of players who stayed in the auction
      function askAllPlayersSimultaneous(chore, bidders, currentPrice) {
        return new Promise(resolve => {
          const overlay = document.createElement('div');
          overlay.className = 'tcg-modal-overlay';
          const modal = document.createElement('div');
          modal.className = 'tcg-modal';
          
          // Dynamic sizing based on viewport and player count
          modal.style.maxWidth = '95vw';
          modal.style.maxHeight = '90vh';
          modal.style.width = 'auto';
          modal.style.height = 'auto';
          modal.style.overflowY = 'auto';
          modal.style.display = 'flex';
          modal.style.flexDirection = 'column';

          // Header
          const header = document.createElement('h3');
          header.textContent = `Auction: "${chore.name}" at ${currentPrice} points`;
          header.style.textAlign = 'center';
          header.style.margin = '0 0 15px 0';
          header.style.fontSize = 'clamp(1rem, 3vw, 1.5rem)';
          header.style.wordWrap = 'break-word';
          modal.appendChild(header);

          // Instructions
          const instructions = document.createElement('p');
          instructions.textContent = 'All players: decide if you want to stay in the bidding or pass';
          instructions.style.textAlign = 'center';
          instructions.style.margin = '0 0 20px 0';
          instructions.style.fontWeight = 'bold';
          instructions.style.fontSize = 'clamp(0.8rem, 2.5vw, 1rem)';
          modal.appendChild(instructions);

          // Scrollable player container
          const playerContainer = document.createElement('div');
          playerContainer.style.flex = '1 1 auto';
          playerContainer.style.overflowY = 'auto';
          playerContainer.style.padding = '0 10px';

          // Player grid with dynamic columns based on player count and screen size
          const playerGrid = document.createElement('div');
          playerGrid.style.display = 'grid';
          
          // Dynamic grid columns based on player count and screen width
          const playerCount = bidders.length;
          let columns;
          if (window.innerWidth < 600) {
            // Mobile: 1 column for small screens
            columns = '1fr';
          } else if (window.innerWidth < 900) {
            // Tablet: 2 columns, but 1 if only 1-2 players
            columns = playerCount <= 2 ? `repeat(${playerCount}, 1fr)` : 'repeat(2, 1fr)';
          } else {
            // Desktop: up to 3-4 columns depending on count
            if (playerCount <= 2) columns = `repeat(${playerCount}, 1fr)`;
            else if (playerCount <= 4) columns = 'repeat(2, 1fr)';
            else if (playerCount <= 6) columns = 'repeat(3, 1fr)';
            else columns = 'repeat(4, 1fr)';
          }
          
          playerGrid.style.gridTemplateColumns = columns;
          playerGrid.style.gap = 'clamp(10px, 2vw, 20px)';
          playerGrid.style.marginBottom = '20px';

          const playerDecisions = new Map();
          const playerElements = new Map();

          bidders.forEach(bidder => {
            // Get player color
            let playerColor = 'gray';
            if (bidder.loc === 'left') playerColor = '#2196F3';
            else if (bidder.loc === 'right') playerColor = '#E53E3E';
            else if (bidder.loc === 'extra1') playerColor = 'orange';
            else if (bidder.loc === 'extra2') playerColor = 'limegreen';
            else if (bidder.loc === 'extra3') playerColor = 'purple';
            else if (bidder.loc === 'extra4') playerColor = 'yellow';
            else if (bidder.loc === 'extra5') playerColor = 'pink';
            else if (bidder.loc === 'extra6') playerColor = 'brown';
            else if (bidder.loc === 'extra7') playerColor = 'gray';
            else if (bidder.loc === 'extra8') playerColor = 'teal';

            const playerCard = document.createElement('div');
            playerCard.style.border = `3px solid ${playerColor}`;
            playerCard.style.borderRadius = '10px';
            playerCard.style.padding = 'clamp(10px, 2vw, 15px)';
            playerCard.style.textAlign = 'center';
            playerCard.style.backgroundColor = 'rgba(255,255,255,0.1)';
            playerCard.style.minHeight = 'clamp(120px, 15vh, 180px)';
            playerCard.style.display = 'flex';
            playerCard.style.flexDirection = 'column';
            playerCard.style.justifyContent = 'space-between';

            const playerName = document.createElement('h4');
            playerName.textContent = bidder.name.toUpperCase();
            playerName.style.color = playerColor;
            playerName.style.margin = '0 0 10px 0';
            playerName.style.fontWeight = 'bold';
            playerName.style.fontSize = 'clamp(0.8rem, 2.5vw, 1.1rem)';
            playerName.style.wordWrap = 'break-word';
            playerCard.appendChild(playerName);

            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = 'clamp(5px, 1vw, 10px)';
            buttonContainer.style.justifyContent = 'center';
            buttonContainer.style.flexWrap = 'wrap';

            const stayBtn = document.createElement('button');
            stayBtn.textContent = 'Stay In';
            stayBtn.style.backgroundColor = '#4CAF50';
            stayBtn.style.color = 'white';
            stayBtn.style.border = 'none';
            stayBtn.style.padding = 'clamp(6px, 1.5vw, 10px) clamp(8px, 2vw, 16px)';
            stayBtn.style.borderRadius = '5px';
            stayBtn.style.cursor = 'pointer';
            stayBtn.style.fontWeight = 'bold';
            stayBtn.style.fontSize = 'clamp(0.7rem, 2vw, 0.9rem)';
            stayBtn.style.flex = '1';
            stayBtn.style.minWidth = '70px';

            const passBtn = document.createElement('button');
            passBtn.textContent = 'Pass';
            passBtn.style.backgroundColor = '#f44336';
            passBtn.style.color = 'white';
            passBtn.style.border = 'none';
            passBtn.style.padding = 'clamp(6px, 1.5vw, 10px) clamp(8px, 2vw, 16px)';
            passBtn.style.borderRadius = '5px';
            passBtn.style.cursor = 'pointer';
            passBtn.style.fontWeight = 'bold';
            passBtn.style.fontSize = 'clamp(0.7rem, 2vw, 0.9rem)';
            passBtn.style.flex = '1';
            passBtn.style.minWidth = '70px';

            const statusText = document.createElement('div');
            statusText.style.marginTop = 'clamp(5px, 1vw, 10px)';
            statusText.style.fontWeight = 'bold';
            statusText.style.fontSize = 'clamp(0.7rem, 2vw, 0.9rem)';
            statusText.style.height = 'clamp(15px, 3vh, 25px)';
            statusText.style.display = 'flex';
            statusText.style.alignItems = 'center';
            statusText.style.justifyContent = 'center';

            stayBtn.addEventListener('click', () => {
              playerDecisions.set(bidder.loc, true);
              stayBtn.style.backgroundColor = '#2E7D32';
              passBtn.style.backgroundColor = '#f44336';
              statusText.textContent = 'âœ“ Staying In';
              statusText.style.color = '#4CAF50';
              checkAllDecided();
            });

            passBtn.addEventListener('click', () => {
              playerDecisions.set(bidder.loc, false);
              passBtn.style.backgroundColor = '#C62828';
              stayBtn.style.backgroundColor = '#4CAF50';
              statusText.textContent = 'âœ— Passed';
              statusText.style.color = '#f44336';
              checkAllDecided();
            });

            buttonContainer.appendChild(stayBtn);
            buttonContainer.appendChild(passBtn);
            playerCard.appendChild(buttonContainer);
            playerCard.appendChild(statusText);

            playerGrid.appendChild(playerCard);
            playerElements.set(bidder.loc, { stayBtn, passBtn, statusText });
          });

          playerContainer.appendChild(playerGrid);
          modal.appendChild(playerContainer);

          // Bottom buttons (fixed at bottom)
          const actions = document.createElement('div');
          actions.style.display = 'flex';
          actions.style.justifyContent = 'center';
          actions.style.gap = 'clamp(10px, 2vw, 20px)';
          actions.style.padding = '15px 0 0 0';
          actions.style.borderTop = '1px solid #ccc';
          actions.style.flexShrink = '0';

          const quitBtn = document.createElement('button');
          quitBtn.textContent = 'Quit Auction';
          quitBtn.style.backgroundColor = '#E24A4A';
          quitBtn.style.color = 'white';
          quitBtn.style.border = 'none';
          quitBtn.style.padding = 'clamp(8px, 2vw, 12px) clamp(12px, 3vw, 20px)';
          quitBtn.style.borderRadius = '5px';
          quitBtn.style.cursor = 'pointer';
          quitBtn.style.fontWeight = 'bold';
          quitBtn.style.fontSize = 'clamp(0.8rem, 2.5vw, 1rem)';

          const confirmBtn = document.createElement('button');
          confirmBtn.textContent = 'Confirm Decisions';
          confirmBtn.style.backgroundColor = '#ccc';
          confirmBtn.style.color = '#666';
          confirmBtn.style.border = 'none';
          confirmBtn.style.padding = 'clamp(8px, 2vw, 12px) clamp(12px, 3vw, 20px)';
          confirmBtn.style.borderRadius = '5px';
          confirmBtn.style.cursor = 'not-allowed';
          confirmBtn.style.fontWeight = 'bold';
          confirmBtn.style.fontSize = 'clamp(0.8rem, 2.5vw, 1rem)';
          confirmBtn.disabled = true;

          function checkAllDecided() {
            if (playerDecisions.size === bidders.length) {
              confirmBtn.style.backgroundColor = '#4CAF50';
              confirmBtn.style.color = 'white';
              confirmBtn.style.cursor = 'pointer';
              confirmBtn.disabled = false;
            }
          }

          quitBtn.addEventListener('click', () => {
            cleanup();
            resolve('quit');
          });

          confirmBtn.addEventListener('click', () => {
            const responses = bidders.map(bidder => ({
              bidder,
              accepted: playerDecisions.get(bidder.loc) || false
            }));
            cleanup();
            resolve(responses);
          });

          function cleanup() {
            try { overlay.remove(); } catch (e) { }
          }

          // Handle window resize to adjust grid
          function handleResize() {
            const newPlayerCount = bidders.length;
            let newColumns;
            if (window.innerWidth < 600) {
              newColumns = '1fr';
            } else if (window.innerWidth < 900) {
              newColumns = newPlayerCount <= 2 ? `repeat(${newPlayerCount}, 1fr)` : 'repeat(2, 1fr)';
            } else {
              if (newPlayerCount <= 2) newColumns = `repeat(${newPlayerCount}, 1fr)`;
              else if (newPlayerCount <= 4) newColumns = 'repeat(2, 1fr)';
              else if (newPlayerCount <= 6) newColumns = 'repeat(3, 1fr)';
              else newColumns = 'repeat(4, 1fr)';
            }
            playerGrid.style.gridTemplateColumns = newColumns;
          }

          window.addEventListener('resize', handleResize);

          // Cleanup resize listener when modal closes
          const originalCleanup = cleanup;
          cleanup = function() {
            window.removeEventListener('resize', handleResize);
            originalCleanup();
          };

          actions.appendChild(quitBtn);
          actions.appendChild(confirmBtn);
          modal.appendChild(actions);
          overlay.appendChild(modal);
          document.body.appendChild(overlay);
        });
      }

      async function auctionSingle(chore, bidders) {
        // bidders is an array of {loc: 'left'|'right'|'extra1'|'extra2', name: 'Name'}
        let currentPrice = 45;
        let activeBidders = [...bidders]; // Track who can still bid

        while (currentPrice >= 5 && activeBidders.length > 0) {
          // If we're at 5 points, randomly assign to one of the remaining bidders
          if (currentPrice === 5) {
            const randomBidder = activeBidders[Math.floor(Math.random() * activeBidders.length)];
            chore.loc = randomBidder.loc;
            chore.points = 5;
            return { abort: false };
          }

          // Ask each active bidder if they want to stay in the bidding
          const responses = [];

          for (const bidder of activeBidders) {
            // Get player color based on location
            let playerColor = '';
            if (bidder.loc === 'left') playerColor = '#66CED6';
            else if (bidder.loc === 'right') playerColor = '#FF4242';
            else if (bidder.loc === 'extra1') playerColor = 'orange';
            else if (bidder.loc === 'extra2') playerColor = 'limegreen';
            else if (bidder.loc === 'extra3') playerColor = 'purple';
            else if (bidder.loc === 'extra4') playerColor = 'yellow';
            else if (bidder.loc === 'extra5') playerColor = 'pink';
            else if (bidder.loc === 'extra6') playerColor = 'brown';
            else if (bidder.loc === 'extra7') playerColor = 'gray';
            else if (bidder.loc === 'extra8') playerColor = 'teal';

            const decision = await askYesNoQuit(
              `Will <span style="color: ${playerColor}; font-weight: bold;">${bidder.name.toUpperCase()}</span> stay in for "${chore.name}" at ${currentPrice} points?`,
              'Yes',
              'No',
              'Quit Auction'
            );
            if (decision === 'quit') {
              return { abort: true };
            }
            const accepted = (decision === 'yes');
            responses.push({ bidder, accepted });
          }

          // Filter to only bidders who said yes
          activeBidders = responses.filter(r => r.accepted).map(r => r.bidder);

          // If only one bidder left, assign to them at current price
          if (activeBidders.length === 1) {
            chore.loc = activeBidders[0].loc;
            chore.points = currentPrice;
            return { abort: false };
          }

          // If no one left, assign to random original bidder at 5 points
          if (activeBidders.length === 0) {
            const randomBidder = bidders[Math.floor(Math.random() * bidders.length)];
            chore.loc = randomBidder.loc;
            chore.points = 5;
            return { abort: false };
          }

          // Lower the price for next round
          currentPrice -= 5;
        }

        // Fallback: assign to random remaining bidder at 5 points
        if (activeBidders.length > 0) {
          const randomBidder = activeBidders[Math.floor(Math.random() * activeBidders.length)];
          chore.loc = randomBidder.loc;
          chore.points = 5;
          return { abort: false };
        } else {
          const randomBidder = bidders[Math.floor(Math.random() * bidders.length)];
          chore.loc = randomBidder.loc;
          chore.points = 5;
          return { abort: false };
        }
      }

      // ===================================
      // RUN AUCTION MAIN FUNCTION
      // ===================================
      // Orchestrates auction for all unassigned chores
      // Gets active players, runs auction for each chore sequentially
      // Can be aborted mid-auction, saves results to localStorage
      async function runAuction() {
        // Kid-Friendly: Auction = everyone raises their hand to keep playing until only one hand is still up.
        // The price (points) goes DOWN, making it easier for someone to win later.
        const chores = loadChores();
        const unchosen = chores.filter(c => !c.loc || c.loc === 'unchosen');
        if (!unchosen.length) {
          notify('No unassigned chores to auction.', 1800);
          return;
        }

        // Get all currently active players as bidders
        const activePlayers = getActivePlayers();
        if (activePlayers.length === 0) {
          notify('No active players to participate in auction.', 1800);
          return;
        }

        const bidders = activePlayers.map(player => ({
          loc: player.loc,
          name: player.name
        }));

        let aborted = false;
        for (const chore of unchosen) {
          const result = await auctionSingleSimultaneous(chore, bidders);
          if (result && result.abort) {
            aborted = true;
            break;
          }
          saveChores(chores);
          render();
        }
        if (aborted) {
          try { notify('Auction cancelled.'); } catch (e) { }
        }
        draftMode = false; // Disable manual assignment buttons
      }

      // ===================================
      // AUCTION BUTTON & SYSTEM
      // ===================================
      // Auction mode: Players bid on each chore, winner gets it assigned
      // Uses modal prompts for each player to bid, highest bidder wins
      const auctionBtn = document.getElementById('auction-btn');
      if (auctionBtn) {
        auctionBtn.addEventListener('click', () => { runAuction(); });
      }

      // ===================================
      // DRAFT BUTTON & SYSTEM
      // ===================================
      // Draft mode: For each chore, asks if it's High or Low difficulty
      // Assigns random points (15-25 for High, 5-10 for Low) in multiples of 5
      // Marks chores with difficulty rating for manual assignment later
      function randomInRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function roundToNearest5(n) {
        return Math.round(n / 5) * 5;
      }

      async function runDraft() {
        // Kid-Friendly: Draft = we look at each chore and say "Easy" or "Hard".
        // Easy chores give smaller points. Hard chores give bigger points.
        // After rating them, we can manually give them to players.
        const chores = loadChores();
        const unchosen = chores.filter(c => !c.loc || c.loc === 'unchosen');
        if (!unchosen.length) {
          notify('No unassigned chores to draft.', 1800);
          return;
        }

        let draftedCount = 0;
        for (const chore of unchosen) {
          const choice = await askHighOrLow(chore.name);
          
          // Handle quit option
          if (choice === 'quit') {
            // If we've drafted at least one chore, enable manual assignment for those
            if (draftedCount > 0) {
              draftMode = true; // Enable manual assignment buttons for drafted chores
              saveChores(chores); // Save progress so far
              render(); // Re-render to show manual assign buttons
              try { notify(`Draft cancelled. ${draftedCount} chore(s) drafted - manual assignment enabled.`); } catch (e) { }
            } else {
              try { notify('Draft cancelled.'); } catch (e) { }
            }
            return; // Exit draft early
          }
          
          let points;
          if (choice === 'high') {
            points = randomInRange(35, 50);
            chore.difficulty = 'difficult';
          } else {
            points = randomInRange(10, 30);
            chore.difficulty = 'easy';
          }
          chore.points = roundToNearest5(points);
          draftedCount++;
        }

        draftMode = true; // Enable manual assignment buttons
        saveChores(chores);
        render();
        notify(`Drafted ${draftedCount} chore(s) with point values.`, 1800);
      }

      const draftBtn = document.getElementById('draft-btn');
      if (draftBtn) {
        draftBtn.addEventListener('click', () => { runDraft(); });
      }

      // re-render when either column header text changes so button labels stay in sync
      [leftHeaderEl, rightHeaderEl].forEach(h => {
        if (!h) return;
        // save header text and re-render as the user types / on blur
        h.addEventListener('keydown', (e) => {
          // Block Enter/new line in contenteditable
          if (e.key === 'Enter') {
            e.preventDefault();
          }
        });
        h.addEventListener('input', () => {
          // Save cursor position before any text changes
          const selection = window.getSelection();
          const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
          const cursorOffset = range ? range.startOffset : 0;
          
          // Remove any newlines and enforce 8-char limit live while typing/pasting
          const raw = (h.textContent || '');
          const noNewlines = raw.replace(/[\r\n]+/g, '');
          const limited = noNewlines.length > HEADER_MAX ? noNewlines.slice(0, HEADER_MAX) : noNewlines;
          
          if (limited !== raw) {
            h.textContent = limited;
            
            // Restore cursor position
            if (range && h.firstChild) {
              const newRange = document.createRange();
              const textNode = h.firstChild;
              const newOffset = Math.min(cursorOffset, limited.length);
              
              try {
                newRange.setStart(textNode, newOffset);
                newRange.setEnd(textNode, newOffset);
                selection.removeAllRanges();
                selection.addRange(newRange);
              } catch (e) {
                // Fallback: place cursor at end
                newRange.selectNodeContents(h);
                newRange.collapse(false);
                selection.removeAllRanges();
                selection.addRange(newRange);
              }
            }
          }
          saveHeaders();
          render();
        });
        h.addEventListener('blur', () => {
          // Ensure no newlines and limit also on blur (trimming allowed here)
          const raw = (h.textContent || '');
          const noNewlines = raw.replace(/[\r\n]+/g, '');
          const trimmed = noNewlines.trim();
          const limited = trimmed.length > HEADER_MAX ? trimmed.slice(0, HEADER_MAX) : trimmed;
          if (limited !== raw) {
            h.textContent = limited;
          }
          saveHeaders();
          render();
        });
      });

      // initial render - load from server first if available, then render
      (async function () {
        await loadStateFromServer();
        render();
        // ensure point display is correct now (in case script ran before DOMContentLoaded)
        renderPoints();
      })();

      // Re-render when extra columns are initialized from storage
      window.addEventListener('extraColumnsReady', () => {
        render();
        renderPoints();
      });

      // Re-render when extra columns are removed to update assign buttons
      window.addEventListener('extraColumnRemoved', () => {
        render();
      });

      // Re-render when extra columns are added to update assign buttons
      window.addEventListener('extraColumnAdded', () => {
        render();
      });

      // ===================================
      // UNASSIGN ALL BUTTON
      // ===================================
      // Moves all assigned chores back to unassigned column with confirmation modal
      const unassignAllBtn = document.getElementById('unassign-all-btn');
      if (unassignAllBtn) {
        unassignAllBtn.addEventListener('click', async function () {
          const chores = loadChores();
          const assigned = chores.filter(c => c.loc && c.loc !== 'unchosen');

          if (!assigned.length) {
            notify('No assigned chores to unassign.', 1800);
            return;
          }

          // Confirmation modal
          const confirmed = await new Promise((resolve) => {
            const overlay = document.createElement('div');
            overlay.className = 'tcg-modal-overlay';
            const modal = document.createElement('div');
            modal.className = 'tcg-modal';

            const p = document.createElement('p');
            p.textContent = `Unassign all ${assigned.length} chore(s)? They will be returned to unassigned.`;
            const actions = document.createElement('div');
            actions.className = 'tcg-modal-actions';

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'Unassign All';

            function cleanup(result) {
              cancelBtn.removeEventListener('click', onCancel);
              confirmBtn.removeEventListener('click', onConfirm);
              try { overlay.remove(); } catch (e) { }
              resolve(result);
            }
            function onCancel() { cleanup(false); }
            function onConfirm() { cleanup(true); }

            cancelBtn.addEventListener('click', onCancel);
            confirmBtn.addEventListener('click', onConfirm);

            actions.appendChild(cancelBtn);
            actions.appendChild(confirmBtn);
            modal.appendChild(p);
            modal.appendChild(actions);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
          });

          if (!confirmed) return;

          // Unassign all chores
          chores.forEach(c => {
            if (c.loc && c.loc !== 'unchosen') {
              c.loc = 'unchosen';
            }
          });

          draftMode = false; // Disable manual assignment buttons
          saveChores(chores);
          render();
          notify(`Unassigned ${assigned.length} chore(s).`, 1800);
        });
      }

      // Constants and functions needed for getActivePlayers - now group-scoped
      function getBaseStateKey() { return `base-player-state_${getCurrentGroup()}`; }
      const BASE_STATE_KEY = `base-player-state_${currentGroup}`;  // Legacy - use getter
      const defaultNames = {
        extra1: 'Player 3',
        extra2: 'Player 4',
        extra3: 'Player 5',
        extra4: 'Player 6',
        extra5: 'Player 7',
        extra6: 'Player 8',
        extra7: 'Player 9',
        extra8: 'Player 10'
      };

      function loadBasePlayerState() {
        try {
          const raw = localStorage.getItem(getBaseStateKey());
          const p = raw ? JSON.parse(raw) : { left: true, right: true };
          return { left: p.left !== false, right: p.right !== false };
        }
        catch (e) { return { left: true, right: true }; }
      }

      // Function to get all active players
      function getActivePlayers() {
        const headers = loadAllHeaders();
        const st = loadExtraState();
        const baseState = loadBasePlayerState();
        const players = [];

        // Add base players only if they're active
        if (baseState.left !== false) {
          players.push({ loc: 'left', name: headers.left || 'Player 1', isExtra: false, isBase: true });
        }
        if (baseState.right !== false) {
          players.push({ loc: 'right', name: headers.right || 'Player 2', isExtra: false, isBase: true });
        }

        for (let i = 1; i <= 8; i++) {
          const extraKey = `extra${i}`;
          if (st[extraKey]) {
            players.push({
              loc: extraKey,
              name: headers[extraKey] || defaultNames[extraKey],
              isExtra: true,
              isBase: false
            });
          }
        }

        return players;
      }
    })();
  </script>

  <script>
    // ===================================
    // ADD/REMOVE PLAYER COLUMN SYSTEM
    // ===================================
    // Manages dynamic player columns (Players 3-10)
    // Handles column creation, removal, reordering, and DOM manipulation
    // Syncs with points bank, headers, and chore assignments
    (function () {
      const addColumnBtn = document.getElementById('add-column-btn');
      const removeColumnBtn = document.getElementById('remove-column-btn');
      const gridSection = document.querySelector('.grid-3');

      // ===================================
      // STORAGE KEYS & CONFIGURATION
      // ===================================
      // Group-scoped storage for column management
      // Note: getCurrentGroup() and key getters are defined earlier in the file

      // Player color scheme for columns 3-10
      const extraColors = {
        extra1: 'orange',
        extra2: 'limegreen',
        extra3: 'purple',
        extra4: 'yellow',
        extra5: 'pink',
        extra6: 'brown',
        extra7: 'gray',
        extra8: 'teal'
      };

      // Default names for extra players
      const defaultNames = {
        extra1: 'Player 3',
        extra2: 'Player 4',
        extra3: 'Player 5',
        extra4: 'Player 6',
        extra5: 'Player 7',
        extra6: 'Player 8',
        extra7: 'Player 9',
        extra8: 'Player 10'
      };

      // ===================================
      // HELPER FUNCTIONS
      // ===================================
      // Local storage helpers for column management module
      function loadAllHeaders() {
        try { const raw = localStorage.getItem(getHeadersKey()); return raw ? JSON.parse(raw) : {}; }
        catch (e) { return {}; }
      }
      function saveHeaderField(field, value) {
        const obj = loadAllHeaders(); obj[field] = value; localStorage.setItem(getHeadersKey(), JSON.stringify(obj));
      }
      function loadExtraState() {
        try { const raw = localStorage.getItem(getExtraStateKey()); const p = raw ? JSON.parse(raw) : { extra1: false, extra2: false, extra3: false, extra4: false, extra5: false, extra6: false, extra7: false, extra8: false }; return { extra1: !!p.extra1, extra2: !!p.extra2, extra3: !!p.extra3, extra4: !!p.extra4, extra5: !!p.extra5, extra6: !!p.extra6, extra7: !!p.extra7, extra8: !!p.extra8 }; }
        catch (e) { return { extra1: false, extra2: false, extra3: false, extra4: false, extra5: false, extra6: false, extra7: false, extra8: false }; }
      }
      function saveExtraState(s) { 
        localStorage.setItem(getExtraStateKey(), JSON.stringify(s)); 
        // Clear saved positions when extra state changes since optimal positions will be different
        clearPositions();
      }

      // Position storage functions
      function loadPositions() {
        try {
          const raw = localStorage.getItem(getPositionsKey());
          return raw ? JSON.parse(raw) : {};
        } catch (e) { return {}; }
      }
      function savePositions(positions) { localStorage.setItem(getPositionsKey(), JSON.stringify(positions)); }
      function clearPositions() { localStorage.removeItem(getPositionsKey()); }

      // Base player state management - now group-scoped (uses getBaseStateKey)
      function loadBasePlayerState() {
        try {
          const raw = localStorage.getItem(getBaseStateKey());
          const p = raw ? JSON.parse(raw) : { left: true, right: true };
          return { left: p.left !== false, right: p.right !== false };
        }
        catch (e) { return { left: true, right: true }; }
      }
      function saveBasePlayerState(s) { 
        localStorage.setItem(getBaseStateKey(), JSON.stringify(s)); 
        // Clear saved positions when base state changes since optimal positions will be different
        clearPositions();
      }

      function loadPoints() {
        try {
          const raw = localStorage.getItem(getPointsKey());
          const parsed = raw ? JSON.parse(raw) : { left: 0, right: 0 };
          if (typeof parsed.left !== 'number') parsed.left = 0;
          if (typeof parsed.right !== 'number') parsed.right = 0;
          if (typeof parsed.extra1 !== 'number') parsed.extra1 = 0;
          if (typeof parsed.extra2 !== 'number') parsed.extra2 = 0;
          if (typeof parsed.extra3 !== 'number') parsed.extra3 = 0;
          if (typeof parsed.extra4 !== 'number') parsed.extra4 = 0;
          if (typeof parsed.extra5 !== 'number') parsed.extra5 = 0;
          if (typeof parsed.extra6 !== 'number') parsed.extra6 = 0;
          if (typeof parsed.extra7 !== 'number') parsed.extra7 = 0;
          if (typeof parsed.extra8 !== 'number') parsed.extra8 = 0;
          return parsed;
        } catch (e) { return { left: 0, right: 0, extra1: 0, extra2: 0, extra3: 0, extra4: 0, extra5: 0, extra6: 0, extra7: 0, extra8: 0 }; }
      }
      function renderPoints() {
        const p = loadPoints();
        const leftEl = document.getElementById('left-points');
        const rightEl = document.getElementById('right-points');
        const extra1El = document.getElementById('extra1-points');
        const extra2El = document.getElementById('extra2-points');
        const extra3El = document.getElementById('extra3-points');
        const extra4El = document.getElementById('extra4-points');
        const extra5El = document.getElementById('extra5-points');
        const extra6El = document.getElementById('extra6-points');
        const extra7El = document.getElementById('extra7-points');
        const extra8El = document.getElementById('extra8-points');
        if (leftEl) leftEl.textContent = String(p.left || 0);
        if (rightEl) rightEl.textContent = String(p.right || 0);
        if (extra1El) extra1El.textContent = String(p.extra1 || 0);
        if (extra2El) extra2El.textContent = String(p.extra2 || 0);
        if (extra3El) extra3El.textContent = String(p.extra3 || 0);
        if (extra4El) extra4El.textContent = String(p.extra4 || 0);
        if (extra5El) extra5El.textContent = String(p.extra5 || 0);
        if (extra6El) extra6El.textContent = String(p.extra6 || 0);
        if (extra7El) extra7El.textContent = String(p.extra7 || 0);
        if (extra8El) extra8El.textContent = String(p.extra8 || 0);
      }

      function updateAddButtonState() {
        if (!addColumnBtn) return;
        const availablePlayers = getAvailablePlayersToAdd();
        const canAdd = availablePlayers.length > 0;
        addColumnBtn.disabled = !canAdd;
        addColumnBtn.style.opacity = canAdd ? '' : '0.5';
        addColumnBtn.style.cursor = canAdd ? '' : 'not-allowed';
      }

      function enableAddButton() {
        updateAddButtonState();
      }

      function disableAddButton() {
        updateAddButtonState();
      }

      function updateRemoveButtonState() {
        if (!removeColumnBtn) return;
        // Count total active players (base + extras)
        const baseState = loadBasePlayerState();
        const st = loadExtraState();
        const activeBases = Object.values(baseState).filter(Boolean).length;
        const activeExtras = Object.values(st).filter(Boolean).length;
        const totalPlayers = activeBases + activeExtras;
        const canRemove = totalPlayers > 1; // Can't go below 1 player
        removeColumnBtn.disabled = !canRemove;
        removeColumnBtn.style.opacity = canRemove ? '' : '0.5';
        removeColumnBtn.style.cursor = canRemove ? '' : 'not-allowed';
      }

      // Function to find the next available extra slot
      function getNextAvailableExtraSlot() {
        const st = loadExtraState();
        for (let i = 1; i <= 8; i++) {
          const extraKey = `extra${i}`;
          if (!st[extraKey]) {
            return i;
          }
        }
        return null; // All slots taken
      }

      // Function to get current active extra players in position order
      function getActiveExtraPlayers() {
        const st = loadExtraState();
        const activeExtras = [];

        for (let i = 1; i <= 8; i++) {
          const extraKey = `extra${i}`;
          if (st[extraKey]) {
            activeExtras.push({
              key: extraKey,
              number: i,
              isLeft: i % 2 === 1
            });
          }
        }

        return activeExtras;
      }

      // Function to calculate optimal grid positions without gaps
      function calculateOptimalPositions() {
        const activeExtras = getActiveExtraPlayers();
        const baseState = loadBasePlayerState();
        
        // Count active base players and ensure they're properly positioned
        const positions = {};

        // Handle base players first - ensure they're always in row 1
        if (baseState.left) {
          const leftColumn = document.getElementById('column-left');
          if (leftColumn) {
            leftColumn.style.gridColumn = '1';
            leftColumn.style.gridRow = '1';
            leftColumn.style.display = ''; // Ensure it's visible
          }
        }
        
        if (baseState.right) {
          const rightColumn = document.getElementById('column-right');
          if (rightColumn) {
            rightColumn.style.gridColumn = '3';
            rightColumn.style.gridRow = '1';
            rightColumn.style.display = ''; // Ensure it's visible
          }
        }

        // Now distribute extra players to balance the columns while preserving original positions
        const totalExtraPlayers = activeExtras.length;
        if (totalExtraPlayers === 0) return positions;

        // Sort extra players by their number to maintain consistent ordering
        const sortedExtras = activeExtras.sort((a, b) => a.number - b.number);

        // Separate players by their original column preference
        const originallyLeft = sortedExtras.filter(p => p.number % 2 === 1); // odd numbers go left
        const originallyRight = sortedExtras.filter(p => p.number % 2 === 0); // even numbers go right

        // Calculate how many should be in each column for balance
        let targetLeftCount = Math.ceil(totalExtraPlayers / 2);
        let targetRightCount = totalExtraPlayers - targetLeftCount;

        // Adjust target counts based on base player presence for better balance
        if (baseState.left && !baseState.right) {
          // Base player on left, reduce left target to balance
          targetLeftCount = Math.floor(totalExtraPlayers / 2);
          targetRightCount = totalExtraPlayers - targetLeftCount;
        } else if (!baseState.left && baseState.right) {
          // Base player on right, reduce right target to balance
          targetRightCount = Math.floor(totalExtraPlayers / 2);
          targetLeftCount = totalExtraPlayers - targetRightCount;
        }

        // Start with players in their preferred columns
        const leftColumnPlayers = [];
        const rightColumnPlayers = [];

        // Place players who originally belong in left column
        originallyLeft.forEach(player => {
          if (leftColumnPlayers.length < targetLeftCount) {
            leftColumnPlayers.push(player);
          } else {
            // Left column is full, move to right
            rightColumnPlayers.push(player);
          }
        });

        // Place players who originally belong in right column
        originallyRight.forEach(player => {
          if (rightColumnPlayers.length < targetRightCount) {
            rightColumnPlayers.push(player);
          } else {
            // Right column is full, move to left
            leftColumnPlayers.push(player);
          }
        });

        // Now position the players, maintaining their number-based order within each column
        leftColumnPlayers.sort((a, b) => a.number - b.number);
        rightColumnPlayers.sort((a, b) => a.number - b.number);

        // Start positioning from row 2 if base players exist, row 1 if they don't
        let leftRowIndex = baseState.left ? 2 : 1;
        let rightRowIndex = baseState.right ? 2 : 1;

        // Assign positions to left column players
        leftColumnPlayers.forEach(player => {
          positions[player.key] = {
            column: 1,
            row: leftRowIndex++
          };
        });

        // Assign positions to right column players
        rightColumnPlayers.forEach(player => {
          positions[player.key] = {
            column: 3,
            row: rightRowIndex++
          };
        });

        return positions;
      }

      // Function to reposition all extra columns to eliminate gaps
      function repositionAllExtraColumns() {
        const positions = calculateOptimalPositions();

        // Update all existing extra columns with their new positions
        Object.keys(positions).forEach(extraKey => {
          const column = document.getElementById(`column-${extraKey}`);
          if (column) {
            const pos = positions[extraKey];
            column.style.gridColumn = pos.column.toString();
            column.style.gridRow = pos.row.toString();
            column.style.display = ''; // Ensure visibility
          }
        });

        // Save the calculated positions to localStorage
        savePositions(positions);
      }

      // Function to restore players to their original positions (when both base players are active)
      function restoreOriginalPositions() {
        const baseState = loadBasePlayerState();
        
        // Ensure base players are properly positioned and visible
        if (baseState.left) {
          const leftColumn = document.getElementById('column-left');
          if (leftColumn) {
            leftColumn.style.gridColumn = '1';
            leftColumn.style.gridRow = '1';
            leftColumn.style.display = ''; // Ensure visibility
          }
        }
        
        if (baseState.right) {
          const rightColumn = document.getElementById('column-right');
          if (rightColumn) {
            rightColumn.style.gridColumn = '3';
            rightColumn.style.gridRow = '1';
            rightColumn.style.display = ''; // Ensure visibility
          }
        }

        // Restore extra players to their original alternating pattern, filling gaps
        const activeExtras = getActiveExtraPlayers();
        const positions = {};

        // Sort by original number to maintain proper ordering
        const sortedExtras = activeExtras.sort((a, b) => a.number - b.number);
        
        // Track row positions for each column to eliminate gaps
        let leftRowCounter = 2; // Start after base players
        let rightRowCounter = 2;

        sortedExtras.forEach((player) => {
          const originalIsLeftSide = player.number % 2 === 1;
          
          if (originalIsLeftSide) {
            positions[player.key] = {
              column: 1,
              row: leftRowCounter++
            };
          } else {
            positions[player.key] = {
              column: 3,
              row: rightRowCounter++
            };
          }
        });

        // Apply the original positions without gaps
        Object.keys(positions).forEach(extraKey => {
          const column = document.getElementById(`column-${extraKey}`);
          if (column) {
            const pos = positions[extraKey];
            column.style.gridColumn = pos.column.toString();
            column.style.gridRow = pos.row.toString();
            column.style.display = ''; // Ensure visibility
          }
        });
      }

      // Function to balance players after removal
      function rebalancePlayers() {
        // Reposition all columns to eliminate gaps
        repositionAllExtraColumns();

        // Update the unassigned column position
        updateUnassignedPosition();
      }

      // Function to get available players that can be added
      function getAvailablePlayersToAdd() {
        const headers = loadAllHeaders();
        const baseState = loadBasePlayerState();
        const st = loadExtraState();
        const availablePlayers = [];

        // Check for inactive base players
        if (baseState.left === false) {
          availablePlayers.push({
            loc: 'left',
            name: headers.left || 'Player 1',
            isExtra: false,
            isBase: true
          });
        }
        if (baseState.right === false) {
          availablePlayers.push({
            loc: 'right',
            name: headers.right || 'Player 2',
            isExtra: false,
            isBase: true
          });
        }

        // Check for inactive extra players
        for (let i = 1; i <= 8; i++) {
          const extraKey = `extra${i}`;
          if (!st[extraKey]) {
            availablePlayers.push({
              loc: extraKey,
              name: headers[extraKey] || defaultNames[extraKey],
              isExtra: true,
              isBase: false
            });
          }
        }

        return availablePlayers;
      }

      // Function to get all active players (local copy for this script block)
      function getActivePlayers() {
        const headers = loadAllHeaders();
        const st = loadExtraState();
        const baseState = loadBasePlayerState();
        const players = [];

        // Add base players only if they're active
        if (baseState.left !== false) {
          players.push({ loc: 'left', name: headers.left || 'Player 1', isExtra: false, isBase: true });
        }
        if (baseState.right !== false) {
          players.push({ loc: 'right', name: headers.right || 'Player 2', isExtra: false, isBase: true });
        }

        for (let i = 1; i <= 8; i++) {
          const extraKey = `extra${i}`;
          if (st[extraKey]) {
            players.push({
              loc: extraKey,
              name: headers[extraKey] || defaultNames[extraKey],
              isExtra: true,
              isBase: false
            });
          }
        }

        return players;
      }

      // Player selection modal for addition
      function askPlayerToAdd(availablePlayers) {
        return new Promise((resolve) => {
          const overlay = document.createElement('div');
          overlay.className = 'tcg-modal-overlay';
          const modal = document.createElement('div');
          modal.className = 'tcg-modal';

          const title = document.createElement('h3');
          title.textContent = 'Select Player to Add';
          title.style.margin = '0 0 16px 0';
          title.style.textAlign = 'center';
          modal.appendChild(title);

          const playerGrid = document.createElement('div');
          playerGrid.style.display = 'grid';
          playerGrid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(120px, 1fr))';
          playerGrid.style.gap = '8px';
          playerGrid.style.marginBottom = '16px';

          const buttons = [];
          availablePlayers.forEach(player => {
            const btn = document.createElement('button');
            btn.textContent = player.name.toUpperCase();
            btn.dataset.loc = player.loc;
            btn.style.padding = '8px 12px';
            btn.style.borderRadius = '6px';
            btn.style.border = 'none';
            btn.style.cursor = 'pointer';
            btn.style.color = 'white';
            btn.style.fontWeight = 'bold';
            btn.style.fontSize = '0.9rem';

            // Apply player color
            if (player.loc === 'left') btn.style.backgroundColor = '#2196F3'; // Blue for Player 1
            else if (player.loc === 'right') btn.style.backgroundColor = '#E53E3E'; // Red for Player 2
            else if (player.loc === 'extra1') btn.style.backgroundColor = 'orange';
            else if (player.loc === 'extra2') btn.style.backgroundColor = 'limegreen';
            else if (player.loc === 'extra3') btn.style.backgroundColor = 'purple';
            else if (player.loc === 'extra4') btn.style.backgroundColor = 'yellow';
            else if (player.loc === 'extra5') btn.style.backgroundColor = 'pink';
            else if (player.loc === 'extra6') btn.style.backgroundColor = 'brown';
            else if (player.loc === 'extra7') btn.style.backgroundColor = 'gray';
            else if (player.loc === 'extra8') btn.style.backgroundColor = 'teal';

            // Special styling for yellow text
            if (player.loc === 'extra4') btn.style.color = 'black';

            playerGrid.appendChild(btn);
            buttons.push(btn);

            btn.addEventListener('click', () => {
              resolve(player.loc);
              cleanup();
            });
          });

          modal.appendChild(playerGrid);

          const actions = document.createElement('div');
          actions.style.display = 'flex';
          actions.style.justifyContent = 'center';
          actions.style.gap = '8px';

          const cancelBtn = document.createElement('button');
          cancelBtn.textContent = 'Cancel';
          cancelBtn.style.padding = '8px 16px';
          cancelBtn.style.borderRadius = '6px';
          cancelBtn.style.border = 'none';
          cancelBtn.style.cursor = 'pointer';
          cancelBtn.addEventListener('click', () => {
            resolve(null);
            cleanup();
          });

          actions.appendChild(cancelBtn);
          modal.appendChild(actions);
          overlay.appendChild(modal);
          document.body.appendChild(overlay);

          function cleanup() {
            try { overlay.remove(); } catch (e) { }
          }
        });
      }

      // Player selection modal for removal
      function askPlayerToRemove(players) {
        return new Promise((resolve) => {
          const overlay = document.createElement('div');
          overlay.className = 'tcg-modal-overlay';
          const modal = document.createElement('div');
          modal.className = 'tcg-modal';

          const title = document.createElement('h3');
          title.textContent = 'Select Player to Remove';
          title.style.margin = '0 0 16px 0';
          title.style.textAlign = 'center';
          modal.appendChild(title);

          const playerGrid = document.createElement('div');
          playerGrid.style.display = 'grid';
          playerGrid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(120px, 1fr))';
          playerGrid.style.gap = '8px';
          playerGrid.style.marginBottom = '16px';

          const buttons = [];
          players.forEach(player => {
            const btn = document.createElement('button');
            btn.textContent = player.name.toUpperCase();
            btn.dataset.loc = player.loc;
            btn.style.padding = '8px 12px';
            btn.style.borderRadius = '6px';
            btn.style.border = 'none';
            btn.style.cursor = 'pointer';
            btn.style.color = 'white';
            btn.style.fontWeight = 'bold';
            btn.style.fontSize = '0.9rem';

            // Apply player color
            if (player.loc === 'left') btn.style.backgroundColor = '#2196F3'; // Blue for Player 1
            else if (player.loc === 'right') btn.style.backgroundColor = '#E53E3E'; // Red for Player 2
            else if (player.loc === 'extra1') btn.style.backgroundColor = 'orange';
            else if (player.loc === 'extra2') btn.style.backgroundColor = 'limegreen';
            else if (player.loc === 'extra3') btn.style.backgroundColor = 'purple';
            else if (player.loc === 'extra4') btn.style.backgroundColor = 'yellow';
            else if (player.loc === 'extra5') btn.style.backgroundColor = 'pink';
            else if (player.loc === 'extra6') btn.style.backgroundColor = 'brown';
            else if (player.loc === 'extra7') btn.style.backgroundColor = 'gray';
            else if (player.loc === 'extra8') btn.style.backgroundColor = 'teal';

            // Special styling for yellow text
            if (player.loc === 'extra4') btn.style.color = 'black';

            playerGrid.appendChild(btn);
            buttons.push(btn);
          });

          modal.appendChild(playerGrid);

          // Cancel button
          const cancelWrapper = document.createElement('div');
          cancelWrapper.style.textAlign = 'center';

          const cancelBtn = document.createElement('button');
          cancelBtn.textContent = 'Cancel';
          cancelBtn.style.padding = '8px 16px';
          cancelBtn.style.backgroundColor = '#E24A4A';
          cancelBtn.style.color = 'white';
          cancelBtn.style.border = 'none';
          cancelBtn.style.borderRadius = '6px';
          cancelBtn.style.cursor = 'pointer';

          cancelWrapper.appendChild(cancelBtn);
          modal.appendChild(cancelWrapper);

          overlay.appendChild(modal);
          document.body.appendChild(overlay);

          function cleanup(choice) {
            buttons.forEach(btn => btn.removeEventListener('click', onClick));
            cancelBtn.removeEventListener('click', onCancel);
            try { document.body.removeChild(overlay); } catch (e) { }
            resolve(choice);
          }

          function onClick(e) {
            const loc = e.target.dataset.loc;
            cleanup(loc);
          }

          function onCancel() {
            cleanup(null);
          }

          buttons.forEach(btn => btn.addEventListener('click', onClick));
          cancelBtn.addEventListener('click', onCancel);
        });
      }

      // Position the unassigned chores column so its extended height sits between extra players
      function updateUnassignedPosition() {
        const choresCol = document.getElementById('chores-column');
        if (!choresCol) return;
        const st = loadExtraState();
        const baseState = loadBasePlayerState();
        const hasAnyExtras = Object.values(st).some(Boolean);
        
        // Count total visible players (base + extras)
        let totalVisiblePlayers = 0;
        if (baseState.left !== false) totalVisiblePlayers++;
        if (baseState.right !== false) totalVisiblePlayers++;
        totalVisiblePlayers += Object.values(st).filter(Boolean).length;
        
        if (hasAnyExtras) {
          // Calculate the maximum row needed based on active players
          const activeExtras = getActiveExtraPlayers();
          const leftPlayers = activeExtras.filter(p => p.isLeft);
          const rightPlayers = activeExtras.filter(p => !p.isLeft);
          const maxRowsNeeded = Math.max(leftPlayers.length, rightPlayers.length) + 1; // +1 for base row

          // Keep it in the center column starting at row 1,
          // but span down through all active rows so the extended list appears between the extras
          choresCol.style.gridColumn = '2';
          choresCol.style.gridRow = `1 / ${maxRowsNeeded + 1}`; // Span from row 1 to accommodate all active players
        } else {
          // Reset to default placement
          choresCol.style.gridColumn = '';
          choresCol.style.gridRow = '';
        }
        
        // For mobile: set grid-row to span all visible players
        // This uses a CSS variable that the media query can use
        choresCol.style.setProperty('--total-players', totalVisiblePlayers);
      }

      function attachExtraHeaderHandlers(headerEl, field) {
        if (!headerEl) return;
        headerEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') e.preventDefault();
        });
        
        const enforceAndSave = () => {
          // Save cursor position before any text changes
          const selection = window.getSelection();
          const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
          const cursorOffset = range ? range.startOffset : 0;
          
          const raw = (headerEl.textContent || '');
          const noNewlines = raw.replace(/[\r\n]+/g, '');
          const limited = noNewlines.length > 8 ? noNewlines.slice(0, 8) : noNewlines;
          
          if (limited !== raw) { 
            headerEl.textContent = limited;
            
            // Restore cursor position
            if (range && headerEl.firstChild) {
              const newRange = document.createRange();
              const textNode = headerEl.firstChild;
              const newOffset = Math.min(cursorOffset, limited.length);
              
              try {
                newRange.setStart(textNode, newOffset);
                newRange.setEnd(textNode, newOffset);
                selection.removeAllRanges();
                selection.addRange(newRange);
              } catch (e) {
                // Fallback: place cursor at end
                newRange.selectNodeContents(headerEl);
                newRange.collapse(false);
                selection.removeAllRanges();
                selection.addRange(newRange);
              }
            }
          }
          saveHeaderField(field, limited);
        };
        
        const enforceAndSaveOnBlur = () => {
          // On blur, allow trimming
          const raw = (headerEl.textContent || '');
          const noNewlines = raw.replace(/[\r\n]+/g, '');
          const trimmed = noNewlines.trim();
          const limited = trimmed.length > 8 ? trimmed.slice(0, 8) : trimmed;
          if (limited !== raw) { 
            headerEl.textContent = limited; 
          }
          saveHeaderField(field, limited);
        };
        
        headerEl.addEventListener('input', enforceAndSave);
        headerEl.addEventListener('blur', enforceAndSaveOnBlur);
      }

      function createExtraColumn(extraNum) {
        // Kid-Friendly: Make a brand new player shelf.
        // We copy Player 1's shelf, change its color and name, empty its chores, and place it nicely.
        const columnLeft = document.getElementById('column-left');
        if (!columnLeft) return null;

        const extraKey = `extra${extraNum}`;
        const newColumn = columnLeft.cloneNode(true);
        newColumn.id = `column-${extraKey}`;

        // Initially position based on the original algorithm
        // Will be repositioned by rebalancePlayers() after creation
        const isLeftSide = extraNum % 2 === 1;
        const row = Math.ceil(extraNum / 2) + 1;
        newColumn.style.gridColumn = isLeftSide ? '1' : '3';
        newColumn.style.gridRow = String(row);

        // header
        const header = newColumn.querySelector('.column-header');
        if (header) {
          header.style.backgroundColor = extraColors[extraKey];
          header.style.textAlign = 'center';
          header.style.fontSize = '4vw';
          header.style.fontFamily = 'var(--names_font)';
          const allHeaders = loadAllHeaders();
          header.textContent = (allHeaders[extraKey] && String(allHeaders[extraKey]).trim()) || defaultNames[extraKey];
          attachExtraHeaderHandlers(header, extraKey);
        }

        // points
        const pointsBank = newColumn.querySelector('.points-bank');
        if (pointsBank) {
          pointsBank.id = `${extraKey}-points-bank`;
          const isRightSide = extraNum % 2 === 0;
          if (isRightSide) pointsBank.style.textAlign = 'right';
          const pointsStrong = pointsBank.querySelector('strong');
          if (pointsStrong) {
            pointsStrong.id = `${extraKey}-points`;
            const p = loadPoints();
            pointsStrong.textContent = String(p[extraKey] || 0);
          }
        }

        // list id and clear cloned chores
        const listDiv = newColumn.querySelector('#left-list');
        if (listDiv) {
          listDiv.id = `${extraKey}-list`;
          listDiv.classList.add('chore-dropzone');
          listDiv.dataset.loc = extraKey;
          // Clear any cloned chores from column-left
          listDiv.innerHTML = '<article class="card chore-placeholder">No chores assigned.</article>';
        }

        gridSection.appendChild(newColumn);

        // Ensure the column is visible
        newColumn.style.display = '';

        // save presence
        const st = loadExtraState();
        st[extraKey] = true;
        saveExtraState(st);

        // Reposition all columns to eliminate gaps and maintain proper order
        repositionAllExtraColumns();

        // Reposition unassigned column if needed
        updateUnassignedPosition();
        // Notify drag & drop system that a new column exists
        document.dispatchEvent(new CustomEvent('extra-column-created', { detail: { key: extraKey } }));
        return newColumn;
      }

      function initFromStorage() {
        const st = loadExtraState();
        const baseState = loadBasePlayerState();
        let maxSlot = 0;

        // Handle base player visibility and ensure proper positioning
        const leftColumn = document.getElementById('column-left');
        const rightColumn = document.getElementById('column-right');
        
        if (baseState.left === false) {
          if (leftColumn) leftColumn.style.display = 'none';
        } else {
          // Ensure Player 1 is properly positioned and visible
          if (leftColumn) {
            leftColumn.style.display = '';
            leftColumn.style.gridColumn = '1';
            leftColumn.style.gridRow = '1';
          }
        }
        
        if (baseState.right === false) {
          if (rightColumn) rightColumn.style.display = 'none';
        } else {
          // Ensure Player 2 is properly positioned and visible
          if (rightColumn) {
            rightColumn.style.display = '';
            rightColumn.style.gridColumn = '3';
            rightColumn.style.gridRow = '1';
          }
        }

        // Count how many extras are enabled and create them
        for (let i = 1; i <= 8; i++) {
          const extraKey = `extra${i}`;
          if (st[extraKey]) {
            createExtraColumn(i);
            maxSlot = i;
          }
        }

        // After all columns are created, position them appropriately
        const savedPositions = loadPositions();
        const currentBaseState = loadBasePlayerState();
        
        if (Object.keys(savedPositions).length > 0) {
          // Restore saved positions if they exist
          Object.keys(savedPositions).forEach(extraKey => {
            const column = document.getElementById(`column-${extraKey}`);
            if (column && st[extraKey]) { // Only apply if column exists and is active
              const pos = savedPositions[extraKey];
              column.style.gridColumn = pos.column.toString();
              column.style.gridRow = pos.row.toString();
              column.style.display = '';
            }
          });
        } else {
          // No saved positions, calculate from scratch
          if (currentBaseState.left && currentBaseState.right) {
            // Both base players active - use original alternating pattern
            restoreOriginalPositions();
          } else {
            // One or no base players - use dynamic balancing
            repositionAllExtraColumns();
          }
        }

        // Update button states
        updateAddButtonState();
        updateRemoveButtonState();

        updateRemoveButtonState();
        renderPoints();
        // Dispatch event to notify chores script that extra columns are ready
        window.dispatchEvent(new CustomEvent('extraColumnsReady'));
        // Ensure unassigned column is placed correctly on load
        updateUnassignedPosition();
      }

      if (!addColumnBtn || !gridSection) return;

      // Helper to clear cached header + points for an extra column
      function clearExtraStorage(which) {
        // which should be 'extra1', 'extra2', etc.
        const headers = loadAllHeaders();
        if (headers && Object.prototype.hasOwnProperty.call(headers, which)) {
          delete headers[which];
          localStorage.setItem(getHeadersKey(), JSON.stringify(headers));
        }
        const pts = loadPoints();
        pts[which] = 0;
        localStorage.setItem(getPointsKey(), JSON.stringify(pts));
      }

      // Helper to clear cached header + points for a base player
      function clearBaseStorage(which) {
        // which should be 'left' or 'right'
        const headers = loadAllHeaders();
        if (headers && Object.prototype.hasOwnProperty.call(headers, which)) {
          // Reset to default names instead of deleting
          if (which === 'left') headers[which] = 'Player 1';
          else if (which === 'right') headers[which] = 'Player 2';
          localStorage.setItem(getHeadersKey(), JSON.stringify(headers));
        }
        const pts = loadPoints();
        pts[which] = 0;
        localStorage.setItem(getPointsKey(), JSON.stringify(pts));
      }

      // Helper to reassign chores from a removed column back to unchosen
      function reassignChoresFromColumn(loc) {
        try {
          const raw = localStorage.getItem(getStorageKey());
          if (!raw) return;
          const chores = JSON.parse(raw);
          // Find all chores in this location and set them to unchosen
          chores.forEach(c => {
            if (c.loc === loc) c.loc = 'unchosen';
          });
          localStorage.setItem(getStorageKey(), JSON.stringify(chores));
        } catch (e) {
          console.error('Error reassigning chores:', e);
        }
      }

      // initialize from saved state (if any)
      initFromStorage();

      addColumnBtn.addEventListener('click', async function () {
        // Get available players to add
        const availablePlayers = getAvailablePlayersToAdd();
        if (availablePlayers.length === 0) return; // No players to add

        // Ask user which player to add
        const playerLoc = await askPlayerToAdd(availablePlayers);
        if (!playerLoc) return; // User cancelled

        const player = availablePlayers.find(p => p.loc === playerLoc);
        if (!player) return; // Invalid selection

        if (player.isBase) {
          // Re-enable base player
          const baseState = loadBasePlayerState();
          baseState[playerLoc] = true;
          saveBasePlayerState(baseState);

          // Show and properly position the column
          const columnToShow = document.getElementById(`column-${playerLoc}`);
          if (columnToShow) {
            columnToShow.style.display = '';
            // Ensure proper grid positioning
            if (playerLoc === 'left') {
              columnToShow.style.gridColumn = '1';
              columnToShow.style.gridRow = '1';
            } else if (playerLoc === 'right') {
              columnToShow.style.gridColumn = '3';
              columnToShow.style.gridRow = '1';
            }
          }
        } else {
          // Add extra player
          // Clear cache for the extra column before creating it
          clearExtraStorage(playerLoc);
          // Create the extra column (this will handle positioning automatically)
          const slotNumber = parseInt(playerLoc.replace('extra', ''));
          createExtraColumn(slotNumber);
        }

        // For base players, we need to reposition all extra columns to follow the same logic
        if (player.isBase) {
          repositionAllExtraColumns();
          updateUnassignedPosition();
        }
        // Note: Extra players already get positioned in createExtraColumn()

        // Update button states
        updateRemoveButtonState();
        updateAddButtonState();

        // Trigger re-render to add assign buttons for this column
        window.dispatchEvent(new CustomEvent('extraColumnAdded'));
      });

      // Confirmation helper for removing player
      function askConfirmRemove(playerName, playerColor) {
        return new Promise((resolve) => {
          const overlay = document.createElement('div');
          overlay.className = 'tcg-modal-overlay';
          const modal = document.createElement('div');
          modal.className = 'tcg-modal';

          const p = document.createElement('p');
          p.innerHTML = `Remove <span style="color: ${playerColor}; font-weight: bold;">${playerName.toUpperCase()}</span>? Their chores will be returned to unassigned.`;
          const actions = document.createElement('div');
          actions.className = 'tcg-modal-actions';

          const cancelBtn = document.createElement('button');
          cancelBtn.textContent = 'Cancel';
          const confirmBtn = document.createElement('button');
          confirmBtn.textContent = 'Remove';
          confirmBtn.style.transition = 'background-color 0.2s';

          // Add hover effect to Remove button
          confirmBtn.addEventListener('mouseenter', () => {
            confirmBtn.style.backgroundColor = '#E24A4A';
            confirmBtn.style.color = 'white';
          });
          confirmBtn.addEventListener('mouseleave', () => {
            confirmBtn.style.backgroundColor = '';
            confirmBtn.style.color = '';
          });

          function cleanup(result) {
            cancelBtn.removeEventListener('click', onCancel);
            confirmBtn.removeEventListener('click', onConfirm);
            try { overlay.remove(); } catch (e) { }
            resolve(result);
          }
          function onCancel() { cleanup(false); }
          function onConfirm() { cleanup(true); }

          cancelBtn.addEventListener('click', onCancel);
          confirmBtn.addEventListener('click', onConfirm);

          actions.appendChild(cancelBtn);
          actions.appendChild(confirmBtn);
          modal.appendChild(p);
          modal.appendChild(actions);
          overlay.appendChild(modal);
          document.body.appendChild(overlay);
        });
      }

      // Remove player functionality: allow removing any player (but keep at least 1)
      if (removeColumnBtn) {
        removeColumnBtn.addEventListener('click', async function () {
          console.log('Remove button clicked');
          const players = getActivePlayers();
          console.log('Active players:', players);

          if (players.length <= 1) {
            console.log('Cannot remove - only 1 player left');
            return; // Need at least 1 player
          }

          // Ask user which player to remove
          const playerLoc = await askPlayerToRemove(players);
          if (!playerLoc) return; // User cancelled

          const player = players.find(p => p.loc === playerLoc);
          if (!player) return; // Invalid selection

          // Ask for confirmation
          let playerColor = 'gray';
          if (player.loc === 'left') playerColor = '#2196F3';
          else if (player.loc === 'right') playerColor = '#E53E3E';
          else playerColor = extraColors[playerLoc] || 'gray';

          const confirmed = await askConfirmRemove(player.name, playerColor);
          if (!confirmed) return;

          if (player.isBase) {
            // Handle base player removal - hide the column
            const columnToHide = document.getElementById(`column-${playerLoc}`);
            if (columnToHide) {
              columnToHide.style.display = 'none';
            }

            // Update base player state
            const baseState = loadBasePlayerState();
            baseState[playerLoc] = false;
            saveBasePlayerState(baseState);

            // Clear base player cached data
            clearBaseStorage(playerLoc);
          } else {
            // Handle extra player removal - actually remove the column
            const columnToRemove = document.getElementById(`column-${playerLoc}`);
            if (columnToRemove) {
              columnToRemove.remove();
            }

            // Update storage
            const st = loadExtraState();
            st[playerLoc] = false;
            saveExtraState(st);
            clearExtraStorage(playerLoc);
          }

          // Reassign chores from removed player
          reassignChoresFromColumn(playerLoc);

          // Rebalance all player positions dynamically
          repositionAllExtraColumns();

          // Re-enable add button since we now have room
          enableAddButton();

          // Update remove button state
          updateRemoveButtonState();

          // Trigger re-render to remove assign buttons for this column
          window.dispatchEvent(new CustomEvent('extraColumnRemoved'));

          // Reposition unassigned column if needed
          updateUnassignedPosition();
        });
      }

      // Initialize remove button visual state on load
      updateRemoveButtonState();
      updateAddButtonState();
    })();
  </script>
</body>

</html>